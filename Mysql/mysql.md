# Mysql

## 1.mysql架构与历史

### 1.1.逻辑架构

- ![image-20221205230713220](./image/1.png)
- 第一层客户端服务架构类似于大多数基于网络的客户端/服务器的工具。负责连接处理、授权认证、安全等。
- 大多数Mysql的核心服务都在第二层，负责查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学和加密函数等），所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 第三层存储引擎负责Mysql中的数据的存储和提取。
- 每个客户端都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者Cpu中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程（线程池）

### 1.2.并发控制

#### 1.2.1.读写锁

- 在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）
  - 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一资源而互不干扰
  - 写锁是排他的，写锁会阻塞其他的写锁和读锁

#### 1.2.2.锁粒度

- 任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高
- 锁策略：在锁的开销和数据的安全性之间寻求平衡，大多数的商用数据库系统一般都是在表上施加行级锁，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能的提供更好的性能
- 每种Mysql的存储引擎都可以实现自己的锁策略和锁粒度
  - 表锁：Mysql最基本的策略，并其实开销最小的策略。会锁定整张表。进行写操作前，需要先获得写锁，会阻塞其他用户对该表的所有读写操作。开销小，并发程度低
  - 行锁：最大程度地支持并发处理。行锁只在存储引擎层实现

### 1.3.事务

- 原子性(atomicity)：一个事务必须被视为一个不可分割地最小工作单元，整个事务中地所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作
- 一致性(consistency)：数据库总是从一个一致性状态转换到另一个一致性状态
- 隔离性(isolation)：一个事务所做的修改在最终提交之前，对于其他事务是不可见的
- 持久性(durability)：一旦事务提交，则所做的修改就会永久存在数据库中

#### 1.3.1.隔离级别

- READ UNCOMMITTED（未提交读、读未提交）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。
- READ COMMITTED（提交读、不可重复读）：一个事务开始时，只能“看见”已经提交的事务所做的修改，也就是说，一个事务从开始直到提交之前，所做的任何修改，对于其他事务都是不可见的。大多数数据库系统的默认隔离级别都是READ COMMITTE（但Mysql）不是。这个级别也叫不可重复读（因为两次相同的查询得到的结果可能是不一样的）
- REPEATEABLE READ（可重复读）：该级别理论上保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别无法解决幻读问题：当某个事物在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。可重复读是Mysql默认的事务隔离级别
- SERIALIZABLE（可串行化）：最高的隔离级别，它通过强制事务串行执行，避免了幻读问题。它会在读取的每一行数据上都加上锁，比较耗费资源
- ![image-20221205235708367](./image/2.png)

#### 1.3.2.死锁

- 两个或多个事务同时在同一资源上相互占用，并请求锁定对方所占用的资源，从而导致恶性循环的现象称为死锁。当多个事务试图以不同顺序锁定资源或多个事务同时锁定统一资源时就可能会会产生死锁
- 为解决死锁问题，数据库实现了各种死锁检测机制和死锁超时机制
- 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁

#### 1.3.3.事务日志

- 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定

#### 1.3.4.mysql中的事务

- 自动提交（auto commit）：Mysql默认自动采用自动提交模式。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作

- ```mysql
  SHOW VARIABLES LIKE 'AUTOCOMMIT';  #查看自动提交是否开启，ON和OFF
  SET AUTOCOMMIT = 1; #开启自动提交
  ```

- 有一些命令，在执行之前会强制执行COMMIT提交当前事务的活动，例如数据库定义语言（DDL）

- 当混用存储引擎时，如果某些存储引擎不支持回滚，那么当回滚时只能回滚支持回滚的存储引擎中的数据

- 隐式和显式锁定：InnoDB采用的时两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁都是在同一时刻被释放，这个过程为隐式锁定；也可以通过以下命令进行隐式锁定：

  - ```mysql
    SELECT ... LOCK IN SHARE MODE;
    SELECT ... FOR UPDATE
    ```

- InnoDB引擎没有必要进行显式加锁，因为它会自动进行隐式加锁，并且性能更好

### 1.4.多版本并发控制

- 多版本并发控制（MVCC）的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
- 不同存储引擎对于MVCC的实现是不一样的，分为乐观MVCC并发控制和悲观MVCC并发控制
- InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号 （system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较

### 1.5.Mysql存储引擎

#### 1.5.1.InnoDB

- InnoDB是Mysql的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行
- 采用MVCC来支持高并发，实现了四个标准的隔离级别，默认是REPEATABLE READ，并且通过间隙锁策略防止幻读的出现，间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入
- InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话， 其他的所有索引都会很大
- InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index），以及能够加速插入操作的插入缓冲区（insert buffer）等

#### 1.5.2.MyISAM

- Mysql5.1及之前的版本的默认存储引擎。支持全文索引、压缩、空间函数等特性，但不支持行锁和事务
- MyISAM对整张表加锁，读取时加共享锁，写入时加排他锁。但是在表有读取查询时可以向其中插入新的记录

#### 1.5.3.其他存储引擎

- Archive：只支持INSERT和SELECT操作，Mysql5.1之前不支持索引。会缓存所有的写并利用zlib对插入的行进行压缩。但是每次SELECT都会进行全表扫描。适合日志和数据采集类的应用
- Blackhole：没有实现任何存储机制，会丢弃所有插入的数据，不做任何保存。但是服务器会记录Blackhole的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志
- Federated：是访问其他Mysql服务器的一个代理，他会创建一个到远程Mysql服务器的客户端连接，并将查询传输到远程服务器执行，并提取或发送需要的数据，默认是禁用的
- Memory：适合快速地访问不会被修改的数据，它的所有数据都保存在内存中，不需要进行磁盘IO，但是它的所有数据在重启后会丢失，表结构会保留
- Merge：MyISAM引擎的变种，它是由多个MyISAM表合并而来的虚拟表
- NDB：集群引擎，作为SQL和NDB原生协议之间的接口

#### 1.5.4.转换表的引擎

- ```mysql
  ALTER TABLE [choose_table_name] ENGINE=INNODB;
  ```

- 如果转换表的存储引擎，将会失去和原引擎相关的所有特性。例如，如果将一张InnoDB表转换为MyISAM，然后再转换回InnoDB，原InnoDB表上所有的外键将丢失

- 可以使用mysqldump工具将数据导出到文件，然后修改文件中的CREATE TABLE语句的存储引擎选项

- 也可以创建一张新表，将原数据复制到新表中，sql如下：

  - ```mysql
    #数据量较小
    CREATE TABLE [new_table_name] LIKE [old_table_name];
    ALTER TABLE [new_table_name] ENGINE=INNODB;
    INSERT INTO [new_table_name] SELECT * FROM [old_table_name];
    #数据量较大
    START TRANSACTION;
    INSERT INTO [new_table_name] SELECT * FROM [old_table_name] WHERE id BETWEEN x AND y; #重复调整x和y的值
    COMMIT;
    ```



## 2.基准测试

- 基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法
- 基准测试可以观察系统在不同压力下的行为，评估系统的容量，掌握哪些是重要的变化，或者观察系统如何处理不同的数据。基准测试可以在系统实际负载之外创造 一些虚构场景进行测试
- 基准测试有两种主要的策略：一是针对整个系统的整体测试，另外是单独测试MySQL
- 测试的指标：
  - 吞吐量：单位时间内的事务处理数
  - 响应时间或者延迟：用于测试任务所需的整体时间
  - 并发性：并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数
  - 可扩展性：简单地说，可扩展性指的是，给系统增加一倍的工作，在理想情况下就能获得两倍的结果（即吞吐量增加一倍）。或者说，给系统增加一倍的资源 （比如两倍的CPU数），就可以获得两倍的吞吐量。当然，同时性能（响应时间）也必须在可以接受的范围内。大多数系统是无法做到如此理想的线性扩展的。随着压力的变化，吞吐量和性能都可能越来越差



## 3.Schema与数据类型优化

### 3.1.选择优化的数据类型

- 数据的类型应该遵循以下几个原则：
  - 更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少
  - 简单就好：简单数据类型的操作通常需要更少的CPU周期。例如整型数据比字符型操作代价更低
  - 尽量避免NULL。如果查询中包含可为NULL的列，对于Mysql来说更难优化，因为可为NULL的列会使得索引、索引统计和值比较都更复杂，并且会占用更多的存储空间

#### 3.1.1.整数类型

- 如果存储整数，可以使用TINYINT、SAMLLINT、MEDIUMINT、INT、BIGINT。它们分别使用8、16、24、32、64位存储空间。取值范围从-2^(N-1)至2(N-1)
- 如果使用UNSIGNED属性，可以使取值范围翻倍
- 限制整形的宽度不会取值范围和占用内存，只会改变显示位数

#### 3.1.2.实数类型

- | 类型名称 | 说明           | 存储需求                              |
  | -------- | -------------- | ------------------------------------- |
  | FLOAT    | 单精度浮点数值 | 4字节                                 |
  | DOUBLE   | 双精度浮点数值 | 8字节                                 |
  | DECIMAL  | 小数值，对     | 对DECIMAL(M,D)，如果M>D为M+2否则为D+2 |

- FLOAT和DOUBLE不指定长度和小数点时，会按照实际存入的数值进行存储，DECIMAL默认为（10，0）
- FLOAT 类型的取值范围如下：
  - 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。
  - 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。
- DOUBLE 类型的取值范围如下：
  - 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。
  - 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。
- DECIMAL存储空间和取值范围都由M和D决定

#### 3.1.3.字符串类型

- VARCHAR用于存储可变长字符串，比定长类型更节省空间，但是需要额外用使用1到2个额外字节记录字符串的长度。如果最大长度小于或等于255字节，只需一个字节表示，否则使用两个字节
- CHAR是定长的：会根据定义的长度分配足够的空间。当存储CHAR值时会删除末尾的空格，会根据需要采用空格进行填充以方便比较
- BINARY和VARBINARY与CHAR和VARCHAR类似，只不过存储的时二进制字符串，BINARY会填充`\0`至指定长度
- Mysql通常会分配固定大小的内存块来保存内布值，这个大小和定义的长度有关，更大的长度会消耗更多的内存。

- BLOB和TEXT是为存储很大的数据而设计的字符串类型，分别采用二进制和字符串方式存储。BLOB分为TINYBLOB、SAMLLBLOB、BLOB、MEDIUMBLOB、LONGBLOCB，TEXT分为TINYTEXT、SAMLLTEXT、TEXT、MEDIUMTEXT、LONGTEXT。BLOB时SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词
- MYSQL会把每个BLOB和TEXT值当作一个独立的对象处理。当BLOB和TEXT值过大时，还会引入专门的外部存储区来进行存储，此时每个值在行内需要1~4字节存储一个指针，然后在外部区域存储实际的值
- MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小max_sort_length的配置，或者使用ORDER BY SUSTRING（column，length ） 
- 如果使用枚举类型ENUM代替字符串，Mysql会在内部存储值实际为整数，并建立映射表以提升性能

#### 3.1.4.日期和时间类型

- DATETIME：范围1001年到9999年，精度为秒。它把日期封装到YYYYMMDDHHMMSS的整数中，占用8个字节存存储空间，没有时区概念
- TIMETAMP：范围1970年到2038年，精度为秒，占用四个字节，有时区概念

#### 3.1.5.位数据类型

- BIT：可以在一列中存储一个或多个true/false值，最大为64位



