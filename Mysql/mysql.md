# Mysql

## 1.mysql架构与历史

### 1.1.逻辑架构

- ![image-20221205230713220](.\image\1.png)
- 第一层客户端服务架构类似于大多数基于网络的客户端/服务器的工具。负责连接处理、授权认证、安全等。
- 大多数Mysql的核心服务都在第二层，负责查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学和加密函数等），所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 第三层存储引擎负责Mysql中的数据的存储和提取。
- 每个客户端都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者Cpu中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程（线程池）

### 1.2.并发控制

#### 1.2.1.读写锁

- 在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）
  - 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一资源而互不干扰
  - 写锁是排他的，写锁会阻塞其他的写锁和读锁

#### 1.2.2.锁粒度

- 任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高
- 锁策略：在锁的开销和数据的安全性之间寻求平衡，大多数的商用数据库系统一般都是在表上施加行级锁，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能的提供更好的性能
- 每种Mysql的存储引擎都可以实现自己的锁策略和锁粒度
  - 表锁：Mysql最基本的策略，并其实开销最小的策略。会锁定整张表。进行写操作前，需要先获得写锁，会阻塞其他用户对该表的所有读写操作。开销小，并发程度低
  - 行锁：最大程度地支持并发处理。行锁只在存储引擎层实现

### 1.3.事务

- 原子性(atomicity)：一个事务必须被视为一个不可分割地最小工作单元，整个事务中地所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作
- 一致性(consistency)：数据库总是从一个一致性状态转换到另一个一致性状态
- 隔离性(isolation)：一个事务所做的修改在最终提交之前，对于其他事务是不可见的
- 持久性(durability)：一旦事务提交，则所做的修改就会永久存在数据库中

#### 1.3.1.隔离级别

- READ UNCOMMITTED（未提交读、读未提交）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。
- READ COMMITTED（提交读、不可重复读）：一个事务开始时，只能“看见”已经提交的事务所做的修改，也就是说，一个事务从开始直到提交之前，所做的任何修改，对于其他事务都是不可见的。大多数数据库系统的默认隔离级别都是READ COMMITTE（但Mysql）不是。这个级别也叫不可重复读（因为两次相同的查询得到的结果可能是不一样的）
- REPEATEABLE READ（可重复读）：该级别理论上保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别无法解决幻读问题：当某个事物在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。可重复读是Mysql默认的事务隔离级别
- SERIALIZABLE（可串行化）：最高的隔离级别，它通过强制事务串行执行，避免了幻读问题。它会在读取的每一行数据上都加上锁，比较耗费资源
- ![image-20221205235708367](.\image\2.png)

#### 1.3.2.死锁

- 两个或多个事务同时在同一资源上相互占用，并请求锁定对方所占用的资源，从而导致恶性循环的现象称为死锁。当多个事务试图以不同顺序锁定资源或多个事务同时锁定统一资源时就可能会会产生死锁
- 为解决死锁问题，数据库实现了各种死锁检测机制和死锁超时机制
- 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁

#### 1.3.3.事务日志

- 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定

#### 1.3.4.mysql中的事务

- 自动提交（auto commit）：Mysql默认自动采用自动提交模式。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作

- ```mysql
  SHOW VARIABLES LIKE 'AUTOCOMMIT';  #查看自动提交是否开启，ON和OFF
  SET AUTOCOMMIT = 1; #开启自动提交
  ```

- 有一些命令，在执行之前会强制执行COMMIT提交当前事务的活动，例如数据库定义语言（DDL）

- 当混用存储引擎时，如果某些存储引擎不支持回滚，那么当回滚时只能回滚支持回滚的存储引擎中的数据

- 隐式和显式锁定：InnoDB采用的时两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁都是在同一时刻被释放，这个过程为隐式锁定；也可以通过以下命令进行隐式锁定：

  - ```mysql
    SELECT ... LOCK IN SHARE MODE;
    SELECT ... FOR UPDATE
    ```

- InnoDB引擎没有必要进行显式加锁，因为它会自动进行隐式加锁，并且性能更好

### 1.4.多版本并发控制

- 多版本并发控制（MVCC）的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
- 不同存储引擎对于MVCC的实现是不一样的，分为乐观MVCC并发控制和悲观MVCC并发控制
- InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号 （system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

