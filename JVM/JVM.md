# JVM学习笔记

## 1.概述

-  JVM是直接运行在操作系统上的，它与硬件没有直接的交互
  - java代码 -> 字节码文件 -> JVM  -> 操作系统
  - 高级语言执行顺序：高级语言 -> 汇编语言 -> 机器指令 -> CPU

- JVM整体结构：
  - ![1](./images/1.png)
  - 多个线程共享方法区和堆，java栈（现在叫虚拟机栈）、本机方法栈、程序计数器是每个线程独有的
-  Java编译器输入的指令流基本上是一种基于**栈的指令集架构**，另一种指令集架构则是基于**寄存器的指令集架构**
  - 基于栈的指令集架构，指令集小（8位）但具体的指令多；基于寄存器的指令集架构，指令集大（16位）但具体的指令少
  - 基于栈的指令集结构是基于内存的，对硬件依赖较小，可以跨平台，但是性能会有所下降；基于寄存器的指令集结构是基于寄存器的，与硬件耦合性较高，性能较高
- JVM的生命周期：
  - 启动：通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。
  - 执行：
    - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
    - 程序开始执行时他才运行，程序结束时他就停止
    - 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程
  - 退出
    - 程序正常执行结束
    - 程序在执行的过程中遇到了异常或错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止
    - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
    - 除此之外，JNI (Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟退出的情况
- JVM发展历程：
  - Sun Classic VM：世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰，这款虚拟机内部只提供解释器，如果使用JIT编译器，就需要外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作。现在hotspot内置了此虚拟机
  - Exact VM：JDK1.2时。sun提供了此虚拟机，可以知道内存中某个位置的数据具体是什么类型。使用热点探测技术，采用编译器和解释器混合工作模式
  - **HotSpot** VM：JDK和OpenJdk的默认虚拟机，HotSpot 意思是指采用热点代码探测技术
  - **JRockit**：专注于服务器应用，不包含解释器实现，世界上最快的JVM，JDK8将一些功能整合至HotSpot上
  - **J9**：和HotSpot，JRockit并列为三大商用虚拟机，广泛用于IBM的各种Java产品
  - KVM和CDC/ CLDC HotSpot：KVM时CLDC-HI早期产品，面向更低端设备；CDC和CLDC HotSpot主要是Oracle用在JAVAE ME产品线上的虚拟机
  - Azul VM和BEA Liquid VM：与特定硬件平台绑定、软硬件配合的专有虚拟机
  - Apache Harmony：兼容JDK 1.5H和1.6，IBM和Intel联合开发的开源JVM，它的Java类库代码吸纳进了Android SDK
  - Microsoft JVM：微软为了在IE3浏览器中支持JAVA Applets，只能在window平台下运行，当时Windows下性能最好的Java VM
  - TaobaoJVM：基于OpenJDK开发的，深度定制且开源的高性能服务器版Java虚拟机，硬件严重依赖intel的cpu，将生命周期的对象从堆中移至堆中，降低GC开销，对象能够在多个Java虚拟机进程中实现共享
  - Dalvik VM：谷歌开发的应用与Android系统的虚拟机，没有遵循Java虚拟机规范，基于寄存器架构，Android 5.0使用支持提前编译的ART VM替换Dalvik VM
  - Graal VM：在HotSopt VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用

## 2.类加载子系统

- 主要步骤：Loading -> Linking -> Initialization即 加载->链接->初始化
  - ![2](./images/2.png)
- 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识
- ClssLoader只负责class文件的加载，至于它是否可以运行，则有Execution Engine巨顶
- 加载的类信息存放于一块成为方法区的内容空间。除了类信息外，方法区中还会包含存放运行时常量池信息，可能还包括字符串字面量和数字厂里（这部分常量信息是Class文件中常量池部分的内存映射）

### 2.1.Loading（加载）

- 加载的顺序：
  - 通过一个类的全限定名获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据访问入口
- 加载.class文件可以从本地系统、网络、zip压缩包、运行时计算生成（动态代理）、由其他文件生成（JSP）、专有数据库中提取、从加密文件中获取（防止被反编译）

### 2.2.Linking（链接）

- 验证(verify)：确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包含：文件格式验证、元数据验证、字节码验证、符号引用验证四种方式。
  - JAVA虚拟机字节码文件开头: KA FE BA BE
- 准备(prepare)：为类变量（静态变量）分配内存并设置该类变量的值为默认初始值
  - 不包含final修饰的static，因为final修饰的变量被看作常量，在编译时就会分配初始值了，准备阶段会显式初始化
  - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到JAVA堆中
- 解析(resolve)：将常量池内的符号引用转换为直接引用的过程
  - 事实上解析操作往往会在JVM初始化之后再执行
  - **符号引用**以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中
  - **直接引用**可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已在内存中存在

### 2.3.Initialization（初始化）

- 初始化阶段就是执行类构造器方法`<clinit>()`的给过程
  - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的复制动作和静态代码块中的语句合并而来
  - 构造器方法中指令按语句在 源文件中出现的顺序执行
  - `<clinit>()`不同于类的构造器
  - 若该类具有父类，jvm会保证父类的`<clinit>()`方法执行完毕后在执行该类的`<clinit>()`方法
  - 虚拟机保证一个类的`<clinit>()`方法在多线程下被同步加锁
  - 如果类中没静态变量、静态代码块，则不会有`<clinit>()`方法

### 2.4.类的加载器分类

- JVM支持两种类型的类的加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这样定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
- 无论类加载器类型如何划分，在程序中我们最常见的类加载器始终只有3个：
  - ![3](./images/3.png)

#### 2.4.1.启动类加载器（BootStrap CLassLoader）

- 这个类加载使用C/C++语音实现的，嵌套在JVM内部
- 它用来加载Java的核心库，用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
- 出于安全考虑，该启动类加载器只加载包名为java、javax、sun等开头的类

#### 2.4.2.扩展类加载器（Extension ClassLoader）

- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
- 派生于ClassLoader类
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性指所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载该类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

#### 2.4.3.应用程序类加载器（系统类加载器，AppClassLoader）

- Java语言编写，由sun.misc.Launcher$AppClassLoader实现
- 派生于ClassLoader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
- 可以通过`ClassLoader.getSystemClassLoader()`方法获取到该类加载器

#### 2.4.4.用户自定义类加载器（User-Defined ClassLoader）

- 使用场景：
  - 隔离加载类（隔离依赖环境，避免类冲突）
  - 修改类加载的方式
  - 扩展加载源
  - 防止源码泄露
- 用户自定义类加载器实现步骤
  - 通过继承抽象类java.lang.ClassLoader，实现自己的类加载器，以满足一些特殊的需求
  - JDK1.2之前通过重写继承的CLassLoader类的`loadClass()`方法，实现自定义的类加载类，JDK1.2之后已不再建议用户覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中
  - 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写`findClass()`方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

### 2.5.双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时，才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式

![4](./images/4.png)

- 工作原理
  1. 如果一个类的加载器收到了类加载请求，它不会先自己去加载，而是把这个请求委托给父类的加载器去执行
  2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归直到启动类加载器
  3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会自己尝试去加载
- 沙箱安全机制： 保护核心代码，防止由引导类加载器加载的核心类被污染



## 3.程序计数器（PC寄存器）

- PC寄存器用来存储指向下一条指令的地址，只占用很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
- 每个线程都会有各自的程序计数器，生命周期与线程保持一致
- 任何时间一个线程都只会有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前正在执行的Java方法的JVM指令地址。如果是在执行native方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成
- 字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域
- 通过PC寄存器，就可以在线程切换回来后，能够从上次暂停的地方继续执行
- cpu计数器概念：为了保证程序（在操作系统中理解为进程）能够连续地执行下去，处理器必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的内存单元地址送入程序计数器，因此程序计数器的内容即是从内存提取的一条指令的地址。当执行指令时，处理器将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。但是，当遇到转移指令如JMP（跳转、外语全称：JUMP）指令时，后继指令的地址（即PC的内容）必须从指令寄存器中的地址字段取得。在这种情况下，下一条从内存取出的指令将由转移指令来规定，而不像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存信息和计数两种功能的结构。



## 4.虚拟机栈

- 由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的
- 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令
- 栈是运行时的单位，堆是存储的单位
- 每个线程都会有各自的虚拟机栈，生命周期与线程保持一致。其内部保存的单位是栈帧，对应着一次次的Java方法调用
- 主管Java程序的运行，他保存方法的局部变量、部分结果，并参与方法的调用和返回，不存在GC，存在OOM
- 访问速度仅次于程序计数器，JVM对于Java栈的操作只有两个
  - 每个方法执行，伴随着进栈
  - 执行结束后的出栈工作
- 栈的大小可以设置为动态变化的，也可以设置为固定不变的。动态情况下，容量不足扩容无法申请到空间时会抛出OOM；固定情况下容量不足会抛出StackOverflow
- `-Xss `参数设置栈最大空间
- 栈顶缓存技术：将栈顶元素全部缓存在物理的cpu的寄存器中，以此降低对对内存的IO次数，提升执行引擎的执行效率

### 4.1.栈的基本结构及运行原理

- 线程上正在执行的每个方法都各自对应一个栈帧
- 栈帧时一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧，只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，当前栈帧对应的方法时当前方法，定义这个方法的类就是当前类
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来放在栈的顶端，成为新的当前栈帧
- 如果当前方法被是被其他方法调用的，方法返回之际，当前栈帧会传回此方法的结果给前一个栈帧（前面所提到的其他方法），接着虚拟机会丢弃当前栈帧（出栈），使得前一个栈帧成为新的当前栈帧
- Java方法有两种返回函数的方式，一种是正常返回（return），另外一种时抛出异常，不管使用那种方式，都会使栈帧被弹出

### 4.2.栈帧内部结构

每个栈帧存储着以下五部分：

1. 局部变量表（Local Variables）
2. 操作数栈 （Operand Stack）（或表达式栈）
3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
4. 方法返回地址 （Return Address）（或方法正常退出或异常退出的定义）
5. 一些附加信息

其中方法返回地址、动态链接和一些附加信息成为帧数据区

#### 4.2.1.局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型（referemce）、对象引用以及returnAddress类型
- 因为是建立在栈上，所以不存在线程间的数据安全问题
- 局部变量表的所需容量大小是在编译期确定下来的，并保存在Code属性的maximum local variables数据项中，在方法运行期是不会改变局部变量表的大小的
- 对于一个函数而言，它的参数和局部方法越多，局部变量表就会越大，它对应的栈帧也会越大。当栈帧被销毁时，局部变量表也会被销毁
- 参数值的存放总是在局部变量表的index0开始，到`数组长度-1`的索引结束。局部变量表最基本的存储单元时Slot（变量槽）
- 32位的数据类型只占用一个Slot，64位的类型（long和double）占用两个slot。byte、short、char、boolean在存储前被转换为int
- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
- 如果当前帧是由构造方法或者实例方法（非静态方法）创建的，那么该对象引用this将会存放在index为0的slot处，其余参数按照参数表顺序继续排列 
- 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收

#### 4.2.2.操作数栈

- 操作数栈是使用数组实现的。`Java虚拟机的解释引擎是基于栈的执行引擎`，其中的栈指定就是操作数栈
- 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈帧是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值
- 栈中的任何一个元素都可以是任意的Java数据类型，32bit的类型占用一个栈深度，64bit的类型占用两个栈深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
- 如果当前方法是被其他方法抵用的其拥有返回值，则当前方法执行结束后，当前方法的返回值会被压入新的当前方法的操作数栈中，并且更新程序计数器中下一条需要执行的字节码指令

#### 4.2.3.动态链接

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用存放在栈帧的动态链接区域。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的方法是，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

#### 4.2.4.方法的调用

- 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关
  - 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期内可知，且运行时保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
  - 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称之为动态链接
- 对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类符号在符号引用被替换为直接引用的过程，这仅仅发生一次。因为面向对象的语言都具备多态的特性，所以自然也具备早期绑定和晚期绑定两种方式
  - 早期绑定：被调用的目标方法如果在编译期可知，且运行时保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用
  - 晚期绑定：如果被调用的方法在编译期无法被确定下来，只能在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定，对应动态链接
- 虚方法和非虚方法：和早期绑定对应的方法称为非虚方法，一般有：静态方法、私有方法、final方法、实例构造器和父类方法；其他方法为非虚方法，与动态连接绑定
- 方法重写的本质：
  1. 找到操作数栈顶的第一个元素所执行的对象实际类型，记作C
  2. 如果在类型C中找到与常量中的描述符合、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lamg.IllegalaAccessError异常
  3. 否则，按照继承关系从下往上以此对C的各个父类进行第2步的搜索和验证过程
  4. 如果没有找到合适的方法，则抛出java.lamg.IllegalaAccessError异常
- 在面向对象的编程中，会很频繁的使用到动态分派（虚方法引用），如果在每次动态分派的过程中都需要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率。因此为了提高性能，JVM采用了在类的方法区建立一个虚方法表来实现。使用索引表来代替查找。
  - 每一个类中都有一个虚方法表，表中存放着各个方法的实际入口
  - 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕

####  4.2.5.方法返回地址

- 存放调用该方法的pc寄存器的值
- 一个方法的结束有两种方式：正常执行完成和出现未处理的异常导致非正常退出
- 无论通过那种方式退出，在方法推出后都是返回到该方法的被调用的位置，方法正常退出后，叫调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常推出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

## 5.本地方法接口

- 一个Native Method就是一个Java调用非Java代码的接口。该方法的实现由非Java语言实现
- Java应用有时需要与Java外面的环境交互，这是本地方法存在的主要原因
- 通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一部分就是用C写的
- Sun的解释器使用C实现的，这使得它能像一些普通的C一样与外部交互



## 6.本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
- 允许被实现成固定大小和可动态扩展的内存大小（内存溢出方面和虚拟机栈相同）
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存
- 并不是所有的JVM都支持本地方法，因为Java虚拟机规范没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈
- 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一



## 7.堆

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
- Java堆区在JVM启动的时候被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间，它的大小也是可以调节的
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区
- 《Java虚拟机规范》中堆Java的描述是：所有的对象实例以及数组都应当在运行时分配在堆上，数组和对象可能永远不会存储在栈上，栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。（由例外情况，对象实例和数组可能存储在栈中）
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
- 堆是GC执行垃圾回收的重点区域
- 现代垃圾收集器大部分都基于分代收集理论设计
  - Java 7及之前的内存逻辑上分为三部分：新生区+养老区+永久区
  - Java及以后堆内存逻辑上分为：新生区+养老区+元空间
  - ![5](./images/5.png)

- 只要是对象实例必然会在Java堆中分配

### 7.1.堆空间大小设置

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设计好了，可以通过`-Xmx`和`Xms`进行设置
  - `-Xms`用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`
  - `-Xmx`则用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`
- 一旦堆区中的内存超过`-Xmx`所指定的最大内存时，则会抛出OOM异常
- 默认情况下，`-Xms`为电脑物理内存的1/64，`-Xmx`为电脑物理内存的1/4



### 7.2.年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类：
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期非常长，在某些极端情况下还能够与JVM的生命周期保持一致
- Java堆区进一步细分的话可以划分为年轻代和老年代
- 其中年轻代又可划分为Eden空间、Survivor0空间和Survivor1空间（也叫from区和to区）
- ![6](./images/6.png)
- 配置新生代和老年代在对接口的占比：
  - 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改`-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1，可以通过`-XX:SurvivorRation`调整这个空间比例，默认是有自适应的内存分配机制，必须由显式指令指定才会是8：1：1
- 几乎所有的Java对象都是在Eden区被new出来的
- 绝大部分的Java对象的销毁都在新生代进行了
- 可以使用选项`-Xmn`设置新生代最大内存大小，优先级高于`-XX:NewRatio=2`

### 7.3.对象分配过程

- new的对象优先放在伊甸区，此区大小有限制
- 伊甸区空间首次被填满时，会对伊甸区进行判断，将没有被引用的对象进行销毁，将剩余的对象移动至from区；如果非首次填满时，会同时对伊甸区和from区进行判断，销毁没有被引用的对象，将伊甸区和from区的对象移动至to区。然后再在伊甸区创建新的对象，按照这样的逻辑进行重复。这个过程称为YGC（Young GC）或Minor GC，每经历过一次GC，对象的年龄计数器就会加一
- 默认15次没有回收掉会被移动到老年区，可以通过参数修改：`-XX:MaxTenuringThreshold=<N>`来设置
- 幸存者区满时不会触发YGC，会有可能直接晋升至老年代
- 垃圾回收频繁发生在年轻代，很少在老年代发生，几乎不在永久区/元数据区发生
- ![7](./images/7.png)
- JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分回收都发生在新生代，针对于HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集，一种是整堆收集
  - 部分收集：不是完整收集整合Java堆的垃圾收集，其中又分为：
    - 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集
    - 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集
      - 目前，只有CMS GC会有单独收集老年代的行为
      - 很多时候Major GC回合Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收

    - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
      - 目前，只有G1 GC会有这种行为

  - 整堆收集（FULL GC）：收集整个java堆和方法区的垃圾收集

- YGC触发机制：
  - 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发GC
  - 因为Java对象大多都具备朝生夕灭的特性，所以YGC非常频繁，一般回收速度也比较快。
  - Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行

- 老年代GC（Major GC / Full GC）触发机制：
  - 指发生在老年代的GC，出现了Major GC时，经常会伴随至少一次的YGC（但并非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）
    - 也就是是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

  - Major GC的速度一般会比YGC慢10倍以上，STW的时间更长
  - 如果Major GC后内存还不足，就会发生OOM

- Full GC触发机制：
  - 调用System.gc()时
  - 老年代空间不足时
  - 方法区空间不足
  - 通过YGC后进入老年代的平均大小大于老年代的可用内存
  - 有Eden区、from区向to区复制时，对象大小大于to区可用内存，则把该对象转为老年代，且老年代的可用内存大小小于该对象的大小


### 7.4.内存分配策略

- 针对不同年龄段的对象分配原则如下所示：
  - 优先分配到Eden
  - 大对象直接分配到老年代
  - 长期存活的对象分配到老年代
  - 动态对象年龄判断
    - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
  - 空间分配担保：`-XX:HadnlePromotionFailure`

### 7.5.TLAB

- TLAB：Thread Loacl Allocation Buffer
- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要使用加锁等机制，进而印象分配速度
- 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略
- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
- 可以通过`-XX:UserTLAB`来控制是否开启TLAB空间
- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，可以通过`-XX:TLABWasteTargetPercent`设置TLAB空间所占Eden空间的百分比大小
- 一旦对象在TLAB空间分配失败时，JVM就会尝试使用加速机制确保数据操作的原子性，从而直接在Eden空间中分配内存

### 7.6.常用参数

[官网说明](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)

- -XX:+PrintFlagsInitial：查看所有的参数的默认初始值

- -XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）

  > 具体查看某个参数的命令行指令：
  >
  > - jps：查看当前运行中的进程
  > - jinfo -flag SurvivorRatio 进程id

- -Xms：初始堆空间内存（默认为物理内存的1/64）

- -Xmx：最大堆空间内存（默认为物理内存的1/4）

- -Xmn：设置新生代的大小。（初始值及最大值）

- -XX:NewRatio：配置新生代与老年代在堆结构的占比

- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例（如果Eden区太大，导致Sx过小，就会导致Minor GC失去意义，每次回收都往老年代放了；如果Eden区过小，会导致Minor GC频率高，而且可能导致很多小对象直接进入老年代。）

- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄（年龄最大是15，是因为GC年龄存储在对象头中用4bit存储，最大就是15）

- -XX:+PrintGCDetails：输出详细的GC处理日志

  - 打印gc简要信息：① -XX:+PrintGC（是-XX:+PrintGCDetails的简化版） ② -verbose:gc

- -XX:HandlePromotionFalilure：是否设置空间分配担保

  - 在发生Minor GC之前，虚拟机会**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。
  - 如果大于，则此次Minor GC是安全的
  - 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。
    - 如果HandlePromotionFailure=true，那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
      - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
      - 如果小于，则改为进行一次Full GC。
    - 如果HandlePromotionFailure=false，则改为进行一次Full GC。
  - 在JDK6 Update24之后（JDK7），HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC**。

### 7.7.堆是否为分配对象的唯一选择

- 随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了
- 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是有一种特殊情况：如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化为栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了，这也是最常见的堆外存储技术
- 逃逸分析：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为参数被传递到其他地方中
- 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定这个对象是否将要分配在堆上
- JDK7默认开启逃逸分析
  - 通过`-XX:+DoEscapeAnalysis`显式开启逃逸分析
  - 通过`-XX:+PrintEscapeAnalysus`查看逃逸分析的筛选结果
- 因此在开发中能使用局部变量的，就不要在方法外定义
- 使用逃逸分析，编译器可对代码做如下优化：
  - 栈上分配：将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
  - 同步省略：如果一个对象被发现只能从一个线程访问到，那么对于这个对象的操作可以不考虑同步
  - 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中
    - 标量是指一个无法再分解为更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量，Java中的对象就是聚合量，因为它可以分解为其他的聚合量和标量
    - 在JIT阶段，如果经过逃逸分析，发现一个对象如果不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其其中包含的若干个成员变量来代替，这就是标量替换
    - 默认打开，可以通过`-XX:+EliminateAllocations`来显式开启
- 目前逃逸分析技术还不是很成熟，无法保证逃逸分析造成的性能消耗一定高于它减少的消耗，因此目前Hotspot未开启栈上分配，所有的对象仍是分配在堆上的，但是标量替换是在使用的



## 8.方法区

- 方法区可以看作是一块独立于Java堆的内存空间，各个线程间共享
- 方法区在JVM启动时的时候被创建，内存逻辑上连续，物理上可以不连续，关闭JVM时会释放这个区的内存
- 可以选择固定大小或者动态扩展
  - JDK7及以前：`-XX:PermSize`设置永久代初始分配空间，默认是20.75M，`-XX:MaxPermSize`设置永久代最大可分配空间，32为默认64M，64位默认82M
  - JDK8及以后：`-XX:MetaSpaceSize`设置元空间初始分配空间，默认值依赖于平台，Windows是21M，`-XX:MaxMetaSpaceSize`设置元空间最大可分配空间，默认值是-1即没有限制。初始元空间的大小相当于一个水位线，如果达到了这个大小会触发Full GC，卸载一些没用的类，如果Full GC释放的空间较小会适当的提高这个水位线，如果释放的空间较多会适当的降低这个水位线。为了避免频繁GC，可以将初始值设置为一个相对较高的值
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区移除，虚拟机回报OOM错误
- jdk7及以前，习惯上把方法区称为永久代，jdk8开始，使用元空间取代了永久代。本质上方法区和永久代不等价，仅仅是对hotspot而言是等价的。永久代使用的JVM的内存，元空间使用的本地内存，二者的内部结构也有区别

### 8.1.方法区的内部结构

- ![8](./images/8.png)

- 方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 类型信息：对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
  - 这个类型的完整有效名称（全名=包名.类名）
  - 这个类型直接父类的完整有效名（对于interface或java.lang.Object而言，都没有父类）
  - 这个类型的修饰符（public, abstract, final的某个子集）
  - 这个类型直接接口的一个有序列表
- 域信息：
  - JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
  - 域的相关信息包括：域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)
- 方法信息
  - 方法名称
  - 方法的返回类型
  - 方法参数的数量和类型
  - 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的某个子集)
  - 方法的字节码(bytecodes)、操作数栈、局部变量表大小
  - 异常表
    - 每个异常处理开始的位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
- non-final的类变量：静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。类变量被类的所有实例共享，即使没有类实例时也可以访问
- 全局常量：static final的类变量，在编译时就会被赋值
- jdk1.6及之前：有永久代，静态变量存放在永久代上
- jdk1.7：有永久代，但已逐步去永久代，字符串常量池、静态变量保存在堆中
- jdk1.8：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍存在堆中

### 8.2.常量池

- 方法区内部包含了运行时常量池，字节码文件内部包含了常量池
- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表，包括各种字面量和对类型、域和方法的符号引用
- 常量池可以看作是一张表，虚拟机指令根据这张常量表找打要执行的类型、方法名、参数类型、字面量等类型
- 运行时常量池是方法区的一部分，常量池表时Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
- 运行时常量池在加载类和接口到虚拟机后，就会创建对应的运行时常量池
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据线就像数组一样，是通过索引访问的
- 运行时常量池中包含多种不通的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段的引用。此时不再是常量池中的符号地址了，这里转换为真实地址
  - 运行时常量池相对Class文件常量池另一重要的特征是：具备动态性
- 运行时常量池类似于传统语言中的符号表，但是它所包含的数据却比符号更加丰富一些
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值会报OOM



## 9.对象的实例化内存布局与访问定位

### 9.1.对象的实例化

- ![9](./images/9.png)
- 指针碰撞：内存规整的情况下，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的治时期。分配内存就仅仅是把指针向空闲那边移动一段与对象大小相等的距离。如果垃圾收集器是基于压缩算法的，虚拟机就会采用这种分配方式
- 空闲列表：如果内存不规整，虚拟机会维护一个列表，记录哪些内存块是可以使用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的内容

### 9.2.对象的内存布局

- ![10](./images/10.png)

### 9.3.对象的访问定位

- ![11](./images/11.png)

- 句柄访问
  - ![12](./images/12.png)
- 直接指针（HotSpot采用）
  - ![13](./images/13.png)

## 10.直接内存

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
- 直接内存是在Java堆外的、直接向系统申请的内存区间
- 来源于NIO，通过存在堆中的DirectByBufeer操作Native内存
- 通常，访问直接内存的速度会优于Java堆，即读写性能高
  - 因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存
  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
- 可以通过`MaxDirectMemorySize`设置直接内存大小，如果不指定默认与堆的最大值`-Xmx`值相等



## 11.执行引擎

- 执行引擎是Java虚拟机核心的组成部分之一
- 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式
- JVM的主要任务是负责装载字节码到其内部，但字节码不能直接运行在操作系统是，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表以及其他的辅助信息。因此，如果想要一个Java程序运行起来，就需要执行引擎将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

### 11.1.Java代码编译和执行的过程

- ![14](./images/14.png)



- 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

- 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件的内容“翻译”为对应平台的本地机器指令执行
- JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言



### 11.2.机器码、指令、汇编语言

- 机器码：各种用二进制编码方式表示的指令，叫做机器指令码，最开始人们用它来编写程序，这就是机器语言
  - 机器语言虽然能被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出错
  - 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快
  - 机器指令与CPU紧密相关，所以不同种类CPU所对应的机器指令也就不同
- 指令：由于机器码是只有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的0和1序列简化成对应的指令，可读性稍好。由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令对应的机器码也可能不同
- 指令集：不同的硬件平台，各自支持的指令是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集
- 汇编语言：由于指令的可读性还是太差，于是人们又发明了汇编语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行
- 高级语言：为了使计算机用户编程更容易些，后来就出现了各种高级计算机语言，高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序
- 字节码：字节码是一种中间状态的二进制代码，它比机器码更抽象，需要直译器转译后才能成为机器码
  - 字节码主要为了实现特定软件运行和软件环境，与硬件环境无关
  - 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令
    - 字节码的典型应用为Java bytrcode

### 11.3.解释器

- 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译“为对应平台的本地机器指令执行
- 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作
- 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器，现在普遍使用的模板解释器
  - 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下
  - 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能
    - 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成
      - Interpreter模块：实现了解释器的核心功能
      - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令

### 11.4.JIT编译器

- 基于解释器执行效率较低，为了解决这个问题，JVM支持一种叫做即时编译的技术。即时编译的目的就是为了避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。
- 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令以换取更高的执行效率
- 热点代码及探测方式：是否需要启动JIT编译器将字节码直接编译成对应平台的本地机器指令需要根据代码被调用的执行频率而定。关于那些需要被编译为本地代码的字节码，也被称之为热点代码。JIT编译器在运行时会针对那些频繁被调用的热点代码做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能
  - 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为热点代码，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR(On Statck Replacement)编译
  - 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才能达到这个标准？必须需要一个明确的阈值，JIT编译器才会将这些热点代码编译为本地机器指令执行。这里主要依靠热点探测功能
  - 目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测：HotSpot VM会为每个方法都建立两个不同类型的计数器，分别会方法调用计数器和回边计数器
    - 方法调用计数器：用于统计方法的调用次数，默认阈值再Client模式下是1500次，再Server模式下是10000次，超过这个阈值，就会触发JIT编译。这个阈值可以通过虚拟机参数`-XX:ComplieThreshold`来人为设定。当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，若果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后**判断方法调用计数器与与回边计数器之和是否超过方法调用计数器的阈值**。如果已经超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
      - 热度衰减：如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期
      - 进行热度衰减的动作是虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数`-XX:-UseCounterDecay`来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。可以通过`-XX:CounterHalfLifeTime`参数设置半衰周期时间，单位是秒
    - 回边计数器：用于统计循环体的循环次数
- HotSpot VM可以设置程序执行方式
  - `-Xint`：完全采用解释器模式执行程序
  - `-Xcomp`：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
  - `-Xmixed`：采用解释器+即时编译器的混合模式共同执行程序
- HotSpot内置了两个JIT编译器，分别为Client Compiler 和 Server Compiler，简称为C1编译器和C2编译器
  - C1编译器：可以通过`-client`指令指定虚拟机运行在Client环境下，并使用C1编译器。C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。使用方法内联、去虚拟化、冗余消除
  - C2编译器：可以通过`-server`指令指定虚拟机运行在Server环境下，并使用C2编译器。C2编译器会进行耗时较长的优化，以及激进的优化。但优化的代码执行效率更高。使用标量替换、栈上分配、同步消除
- JDK7以后默认开启分层编译策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化

### 11.5.Graal即时编译器和AOT编译器

- JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器。编译效果目前已追平了C2编译器
- JDK9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）。JDK9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输人的Java类文件转换为机器码，并存放至生成的动态共享库中。所谓的AOT编译，是与即时编译相对立的一个概念，即时编译指的是程序运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的是，在程序运行之前，便将字节码转换为机器码的过程
  - 优点：可以直接运行，不必等待预热
  - 缺点：破坏了一次编译，到处运行的特点。降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。目前只支持Linux x64 java base



## 12.Sting Table

- String代表不可变的字符序列，简称：不可变性
  - 当对字符串重新赋值时，需要重新制定内存区域赋值，不能使用原有的内存区域
  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  - 当调用String的replace()方法修改指定字符串时，重新指定内存区域赋值，不能使用原有的value进行赋值
- 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中
- 字符串常量池中是不会存储相同内容的字符串的
- String的String Pool是一个固定大小的HashTable，jdk6默认值大小长度为1009；jdk7和8是60013，jdk8最小值是1009。如果放进String Pool的String非常多，就会造成Hash冲突，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降
- 使用`-XX:StringTableSize`可以设置StringTable的长度

- 直接使用双引号声明出来的String对象会直接存储在常量池中
- 如果不是用双引号声明的String对象，可以是用String提供的intern()方法
- 常量与常量拼接的结果在常量池，原理是编译期优化。只要其中有一个是变量，结果就在堆中（非常量池），变量拼接的原理是StringBuilder。如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

- intern()方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。Interned String就是确保字符串在内存中只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。
- 将一个对象放入字符串常量池：
  - jdk1.6中，如果字符串常量池不存在，则会复制一份，并返回地址；如果存在则会返回地址
  - jdk1.7起：如果不存在，会把对象的引用地址放入字符串常量池，并返回地址；如果存在则会返回地址



## 13.GC

- 垃圾是指再运行程序中没有任何指针指向的对象，这个对象就是需要回收的垃圾
- 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占用的空间会一直保留在程序运行结束，被保留的空间无法被其他对象使用，甚至可能导致内存溢出。

### 13.1.垃圾回收算法

- 在堆中存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中那些是存活对象，那些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称之为垃圾标记阶段。判断对象存活一般有两种方式：引用计数算法和可达性分析算法
- 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的空间，以便有足够的可用内存空间为新对象分配内存，目前JVM中比较常见的三种垃圾收集算法是：标记清除算法（Mark Sweep）、复制算法（Copying）、标记压缩算法（Mark Compact）

#### 13.1.1.引用计数算法

- 为每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加一；当引用失效时，引用计数器就减一。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用。
- 有点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性
- 缺点：
  - 需要单独的字段存储计数器，这样的做法增加了内存空间的开销
  - 每次赋值都需要更新计数器，伴随着加法和减法的操作，增加了时间开销
  - 无法处理循环引用的情况

#### 13.1.2.可达性分析算法

- 相对于引用计数算法而已，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄露的发生
- 实现思路
  - 以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象结合所连接的目标对象是否可达
  - 使用可达性分析算法后，内存中存活的对象会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链
  - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
  - 在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象
- GC Roots的构成：
  - 虚拟机栈中引用的对象
  - 本地方法栈内JNI引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 所有被同步锁synchronized持有的对象
  - Java虚拟机内部的引用
  - 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
  - 如果只针对Java堆中的某一块区域进行回收（比如只针对新生代进行回收），必须考虑到内存区域是虚拟机自己实现的细节，而不是孤立封闭的，这个区域的对象完全有可能被堆中的其他区域的对象所引用，这是就需要一并将关联区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性
  - 需要STW（Stop The World）

#### 13.1.3.对象的finalization机制

- Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法
- finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库链接等。
- 永远不要调用对象的finalize()方法，应该交给垃圾回收机制调用
  - 在finalize()时可能导致对象复活
  - fianlize()方法的执行时间是没有保障的，完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会
  - 一个糟糕的finalize()会严重影响GC的性能
- 由于finalize()方法的存在，虚拟中的对象一般处于三种可能的状态。如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是”非死不可“的，这时候它们暂时处于缓刑阶段。一个无法触及的对象有可能在某一个条件下”复活“自己，如果这样，那么对它的回收就是不合理的，为此，定于虚拟机中的对象的三种状态，如下：
  - 可触及的：从根节点开始，可以达到这个对象
  - 可复活的：对象的所有引用被释放，但是对象有可能在finalize()中复活
  - 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及状态不可能被复活，因为finalize()只会被调用一次，只有此状态下才可以被回收
- 判断一个对象是否可回收，至少经历两次标记过程：
  - 如果对象objA到GC Roots没有引用链，则进行第一次标记
  - 进行筛选，判断此对象是否有必要执行finalize()方法，此次为第二次标记
    - 如果对象objA没有重写finalize()方法，或者已被虚拟机调用过finalize()方法，则虚拟机视为”没有必要执行“，objA被判定为不可触及的
    - 如果objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发器finalize()方法执行
    - finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移除即将回收的集合。之后对象会再出现没有引用存在的情况。在这个情况下，finalize方法不会再被调用，对象会直接变成不可触及的状态，也就是说一个对象的finalize方法只会被调用一次

#### 13.1.4.标记-清除（Mark-Sweep）算法

- 执行过程：当堆中的有效空间被耗尽的时候，就会停止整个程序（STW）然后进行两项工作：标记和清除
  - 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
  - 清除：Collector对堆内存从头到尾进行线下的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。这里的清除并不是真正的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就直接存放。
- 缺点：
  - 效率不算高
  - 在进行GC的过程中，需要STW，用户体验差
  - 这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表

#### 13.1.5.复制（Copying）算法

- 核心思想：将活着的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清楚正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
- 优点：
  - 没有标记和清除的过程，实现简单，运行高效
  - 复制过去以后保证空间的连续性，不会出现碎片问题
- 缺点：
  - 需要两倍的内存空间
  - 对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
- 如果系统中的存活对象很多，复制算法不会很理想；复制算法需要复制的存活对象数量并不会太大，或者说非常低，因此非常适合用于新生代中。

#### 13.1.6.标记压缩（Mark-Compact）算法

- 执行过程：
  - 第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象
  - 第二阶段将所有存活的对象压缩到内存的一端，按顺序排放。之后清理边界外的所有空间
- 优点：
  - 消除了标记清除算法中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可
  - 消除了复制算法当中，内存减半的缺点
- 缺点：
  - 效率上：低于复制算法和标记清除算法
  - 移动对象的同时，如果对象被其他对象引用，需要调整该引用的地址
  - 移动过程中需要STW

#### 13.1.7.分代收集算法

- 对于垃圾回收算法而言，没有最好的算法，只有最适合的场景。分代收集算法是基于这样的一个事实：不同对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以便提高垃圾回收的效率。
- 目前几乎所有的GC都是采用分代收集算法来执行垃圾回收的
  - 年轻代：区域相对于老年代较小，对象生命周期短、存活率低，回收频繁。一般使用复制算法
  - 老年代：区域大，对象生命周期长、存活率高、回收不及年轻代频繁。一般使由标记整理和标记清除算法**混合实现**
    - mark阶段对象开销和存活对象数量成正比
    - sweep阶段的开销与所管理的区域大小成正比
    - compact阶段对象开销和存活对象数量成正比

#### 13.1.8.增量收集算法

- 基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用线程。一次反复，直到垃圾收集完成。总的来说，垃圾收集算法的基础仍是传统的标记清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾回收线程以分阶段的方式完成标记、清除或复制的过程
- 缺点：使用这种方式，由于在垃圾回收过程中，间断性地执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量地下降。

#### 13.1.9.分区算法

- 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿
- 分代收集算法按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间(region)，每一个小区间都独立使用，独立回收。这种算法地好处是可以控制一次回收多少个小区间

### 13.2.垃圾回收相关概念

#### 13.2.1.System.gc()

- 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试放被丢弃对象占用的内存
- System.gc()无法保证对垃圾收集器的调用。使用System.runFinalization()可以强制调用失去引用对象的finalize()方法
- JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动运行的，无须手动触发，否则就会太过于麻烦。在一些特殊情况下，如我们正在编写一个性能基础准，我们可以在运行之间调用System.gc()

#### 13.2.2.内存溢出和内存泄漏

- 内存溢出（OOM）：没有空闲内存，并且垃圾收集器也无法提供更多内存。出现OOM之前一般会发生一次独占式的Full GC操作（如果为一个超大对象分配空间）
- 没有空闲内存的情况：
  - Java虚拟机堆的内存设置不够
  - 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集
- 内存泄漏（Memory Leak）
  - 严格上来讲：只有对象不会再被程序用到了，但GC又不能回收他们的情况，才叫内存泄漏
  - 宽泛的讲：由于一些不太好的实践（或疏忽）导致对象的生命周期变得很长甚至导致OOM，也可以称为内存泄漏
- 内存泄露的例子：
  - 单例模式：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，会导致内存泄漏的产生
  - 一些提供close方法的资源未关闭导致内存泄露，比如数据库连接、网络连接和io连接

#### 13.2.3.Stop The World

- Stop The World：简称STW，指的是GC时时间发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何相应。
- 可达性分析算法中枚举根节点会导致所有Java执行线程停顿
  - 分析工作必须在一个能确保一致性的快照中进行
  - 一致性指整个分析期间整个系统看起来像被冻结在某个时间点上
  - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
- 所有的GC都会有STW发生，要尽量避免STW的发生

#### 13.2.4.并行域并发

##### 13.2.4.1.程序的并行与并发

- 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动到运行完毕之间，且这几个程序都是在同一个处理上运行。并发并不是真正意义上的同时进行，只是CPU把一个时间段划分成几个时间片段，然后在这个几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行
- 并行：当系统有一个以上CPU时，当一个CPU执行一个进行时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。决定并行的因素并不是CPU的数量，而是CPU核心的数量
- 对比：
  - 并发：指的是多个事情，在同一时间段内同时发生。多个任务之间会互相抢占资源
  - 并行：指的是多个事情，在同一时间点上同时发生。多个任务之间不会抢占资源

##### 13.2.4.2.垃圾回收的并发与并行

- 并行：指多条垃圾回收线程并行工作，但此时用户线程仍处于等待状态
- 串行：相较于并行的概念，单线程执行。
- 并发：指用户线程和垃圾回收线程同时执行（但不一定是并行的，可能会交替执行）

#### 13.2.5.安全点和安全区域

- 安全点（Safe Point）：程序执行时，并非在所有地方都能停顿下来开始GC，只有在特定位置才能停顿下来开始GC，这些位置称为安全点。安全的的选择非常重要，如果安全点过少，会导致GC等待时间太长，如果过多会对性能产生影响。通常会根据是否具有让程序长时间执行的特征，做为安全点的选择标准。
- 保证GC发生时，所有的线程都在安全点停顿：
  - 抢先式中断：首先中断所有线程。如果线程不在安全点，就恢复线程，让线程跑到安全点（目前没有虚拟机采用了）
  - 主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起
- 安全区域（Safe Region）：指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的
  - 当线程运行到安全区域的代码时，首先标识已经进入了安全区域，如果这段时间发生GC，JVM会忽略标识为Safe Region状态的线程
  - 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止

#### 13.2.6.引用

- 强引用：最传统的引用定义，是指在程序代码之中普遍存在的引用赋值。无论任何情况下，只要强引用的关系还存在，垃圾收集器就永远不会回收掉被引用的对象。（一定不会收）

  - 一定情况下，强引用时造成内存泄漏的主要原因之一（因为其他引用都能被GC）

- 软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围内进行二次回收（第一次回收是指对不可触及对象的回收，回收完如果内存不够，会发生对软引用的回收）。如果这次回收后还没有足够的内存才会抛出OOM（内存不足即回收）

  - 软引用通常用来实现内存敏感的缓存。比如：高速缓存就用到了软引用。垃圾回收器在某个时刻决定回收软可达的对象时，会清理团引用，并可选的将引用放到一个引用队列

  - ```java
    Object obj = new Object();
    SoftReference<Object> sf = new SoftSoftReference<Object>(obj);
    obj = null;
    ```

- 弱引用：只被弱引用关联的对象只能生存道下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象（发现即回收）

  - 通常用于保存可有可无的缓存数据，当要被回收时也会被放入和软引用类似的引用队列

  - ```java
    Object obj = new Object();
    WeakReference<Object> sf = new WeakSoftReference<Object>(obj);
    obj = null;
    ```

- 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收时收到一个系统通知（对象回收跟踪）

  - ```java
    Object object = new Object();
    ReferenceQueue phantomQueue = new ReferenceQueue();
    PhantomReference<Object> pf = new PhantomReference<>(object, phantomQueue);
    object = null;
    ```

- 终结器引用：实现对象的finalize()方法，无需手动编码，其内部配合引用队列使用。在GC时，终结器引用入队。有Finalizer线程通过终结器引用找到被引用的对象并调用它的finalize()方法，第二次GC时才能回收被引用对象



### 13.3.垃圾回收器

- 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器
  - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收的操作，此时工作线程被暂停，直至垃圾收集工作结束
    - 适合CPU处理器或较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端Client模式下的JVM中
    - 在并发能力比较强的CPU上，并行回收器产生的停顿时间明显低于串行回收器
  - 串行回收器和并行回收器相同，都采用独占式，会造成STW
- 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
  - 并发式垃圾回收器与应用线程交替工作，以尽可能减少应用程序的停顿时间
  - 独占式垃圾回收器一旦运行，就会STW，停止所有用户线程，直至垃圾回收结束
- 按照碎片处理分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器
  - 压缩式垃圾回收器会在内存回收完成后，对存活对象进行压缩整理，消除回收后的碎片
- 按照工作的内存区间分，又分为年轻代垃圾收集器和老年代垃圾收集器



- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1



- ![19](./images/19.png)



- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Paraller Old、CMS
- 整堆收集器：G1



![15](./images/15.png)



- 使用`-XX:+PrintCommandLineFlags`:查看命令行相关参数（包含使用的垃圾收集器），使用`jinfo -flag 相关垃圾回收器参数 进程ID`查看是否使用了相关垃圾回收器

#### 13.3.1.评估GC的性能指标

- 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间：程序运行时间+内存回收的时间）
- 垃圾回收开销：吞吐量的补数，垃圾收集的时间占总运行时间的比例
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：相对于程序的运行，收集操作发生的频率
- 内存占用：Java堆所占的内存大小
- 快速：一个对象从诞生到回收所经历的时间



- 吞吐量、暂停时间和内存占用共同构成一个”不可能三角“。一款优秀的收集器最多同时满足其中两项。随着硬件发展，内存占用越来能被容忍，吞吐量和暂停时间的问题越来越被凸显。随着内存空间的扩大，反而对暂停时间反而带来负面效果。
- 目前的标准：在最大吞吐量优先的情况下，降低停顿时间



#### 13.3.2.Serial回收器：串行回收

- 最基本、历史最悠久的垃圾回收器，JDK1.3之前新生代唯一选择，Client模式下默认的新生代垃圾回收器
- 使用复制算法、串行回收和STW机制的方式执行内存回收
- 针对老年代，提供了Serial Old收集器，使用标记-压缩算法、串行回收和STW的机制执行内存回收，是Client默认的老年代的垃圾回收器
  - Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用、作为老年代CMS垃圾收集器的后备方案

- 优点：**单线程的情况下**，简单而高效，没有线程交互开销，适合运行在Client模式
- 可以是用`-XX:+UseSerialGC`指定年轻代和老年代都是用该串行垃圾回收器
- Serial还可以和CMS配合使用（1.8过时，1.9移除）



#### 13.3.3.ParNew回收器：并行回收

- Par是Parallel（并行）的缩写，New是指新生代。 除了采用并行回收的方式执行垃圾回收内存外，和Serial回收器几乎没有其他区别。适用于新生代，采用并行回收、复制算法和STW方式执行内存回收。
- 可以和CMS（jdk14弃用CMS）或Serial Old（jdk8过时，9移除搭配）配合使用
- 多CPU环境下优于Serial，单CPU环境下比Serial效率低
- 可以通过`-XX:+UseParNewGC`指定新生代使用该收集器，使用`-XX:ParallelGCThreads`限制线程数量，默认开启和CPU核心数相同的线程数



#### 13.3.4.Parallel Scavenge回收器：吞吐量优先

- 采用和ParNew相同的复制算法、并行回收和STW机制
- Parallel收集器的目标时达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾收集器
- 自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别
- 高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用
- 因为与CMS老年代并发收集器不兼容，JDK1.6针对于老年代提供了Parallel Old并行收集器，用来替换Serial Old串行收集器，采用了标记-压缩算法，并行回收和STW机制。
- Parallel Scavenge和Paralel Old是JDK8默认的垃圾收集器组合
- `-XX:+UseParallelGC`：指定年轻代使用Parallel Scavenge回收器
- `-XX:+UseParallelOldGC`：指定老年代使用Parallel Old回收器
- Parallel Scavenge和Parallel Old两个收集器相互激活
- `-XX:ParallerGCThreads`：设置年轻代并行收集器的线程数。一般的，最好与CPU数量相等，以免线程过多，造成线程切换影响性能。
  - 默认情况下，当CPU数量小于8个，收集器线程数的值等于CPU数量
  - 当CPU数量大于8个时：收集器线程数的值等于`3 + [(5 * cpu_count) / 8 ]`
- `-XX:MaxGCPauseMillis`：设置垃圾收集器最大停顿时间（STW），单位是毫秒
  - 为了尽可能地把停顿时间控制在上面的参数以内，收集器在工作时会调整Java堆大小或其他一些参数
  - 对于用户来讲，停顿时间越短，体验越好。但在服务器端，我们注重高并发，整体的吞吐量。所有服务端适合Parallel进行控制
  - 谨慎调整该参数
- `-XX:GCTimeRation`：垃圾收集时间占总时间的比例，用于衡量吞吐量的大小 `1 / (N + 1)`，N为程序运行时间
  - 取值范围：(0, 100)，默认值99，也就是垃圾回收时间不超过1%
  - 与`-XX:MaxGCPauseMillis`参数有一定的矛盾性。暂停时间越长，Ratio参数就越容易超过设定的比例
- `-XX:+UseAdaptiveSizePolicy`：设置Parallel ScaVenge收集器具有自适应调节策略
  - 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点
  - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量和停顿时间，让虚拟机自己完成调优工作

#### 13.3.5.CMS回收器：低延迟

- JDK1.5推出了CMS（Concurrent-Mark-Sweep）收集器，是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作，应用于老年代
- 采用标记-清除算法，并发和STW机制
- ![16](./images/16.png)
- 初始标记阶段：会出现STW，该阶段仅仅只是标记出GC Roots能**直接**关联到的对象，一旦标记完成之后就会恢复之前被暂停的用户线程。由于直接关联对象比较少，所以这里的速度非常快
- 并发标记阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程，可以和垃圾回收线程一起并发运行
- 重新标记阶段：会出现STW，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
- 并发清除：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，这个阶段是可以与用户线程并发的



- 初始标记和重新标记会STW，整体来讲还是存在STW，但是最耗时的并发标记和并发清理阶段是和用户线程一起执行的，所以停顿时间较短，适合强交互类应用。因为在CMS回收过程中，还应确保应用程序的用户线程有足够的内存可用，因此需要在堆内存使用率达到某一个阈值的时候，便开始进行垃圾回收，以确保应用程序在CMS工作过程中仍然后足够的内存空暗金支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟器启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样会造成长时间的停顿。
- 优点：并发收集、低延迟
- 弊端：标记-清除算法会产生内存碎片，如果遇到大对象可能造成无法分配提前触发Full GC
- CCMS收集器对CPU资源非常敏感。在并发阶段，他虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢。总吞吐量会降低
- CMS收集器复发处理浮动垃圾。在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的对象没有被即时回收，只能在下一次GC的时候清理

- `-XX:+UseConcMarkSweepGC`：手动指定使用CMS收集器执行内存回收任务
  - 开启该参数后会自动将`-XX:+UseParNewGC`打开
- `-XX:CMSInitiatingOccupanyFraction`设置内存使用率的阈值，一旦达到该阈值，便开始进行回收
  - JDK5默认值是68，即老年代内存空间使用率达到68%时，会执行一次CMS回收，JDK6及以上的默认值是92
  - 如果内存增长缓慢，可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。
- `-XX:+UseCMSCompactAtFullCollection`：用于指定在执行完FULL GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所以带来的问题就是STW的时间更长了
- `-XX:CMSFullGcsBeforeCompaction`：设置在执行多少次Full GC后对内存空间进行压缩整理
- `-XX:ParallelCMSThreads`：设置CMS线程的数量, 默认线程数是（ParallelGCThreads + 3）/ 4



#### 13.3.6.G1回收器：区域分代化

- G1(Garbage First)：在延迟可控的情况下获得尽可能高的吞吐量。他是一个并行的回收器，把堆内存分割为很多不相关的区域（Region 物理是是不连续的）。使用不同的Region来表示Eden、survivor0、survivor1、老年代等。
- G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾垃圾堆积的大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许收集时间，优先回收价值最大的Region
- 由于这种方式的侧重点在于回收垃圾最大的区间，所以叫做G1(Garbage First)：垃圾优先
- G1是面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。JDK9之后的默认垃圾收集器，被官方称为全功能的垃圾收集器（同时作用于新生代和老年区）
- 并行与并发：
  - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核能力。此时用户线程STW
  - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
- 分代收集：
  - G1属于分代型垃圾回收器，他会区分年轻代和老年代，年轻代依然有Eden区和 Survivor区，但是新生代和老年代从物理内存结构上来看不是连续的，也不再坚持固定的大小和固定数量
  - 将堆空间分成若干个区域，这些区域包含了逻辑上的年轻代和老年代。并且可以同时兼顾年轻代和老年代
- 空间整合：G1将内存划分为一个个的region。内存的回收是以region为基本单位的，Region之间是复制算法，但整体实际上可以看作是标记-压缩算法。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC
- 可预测的停顿时间模型（软实时soft real-time）：
  - 由于分区原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿的情况的发生也能得到较好的控制
  - G1跟踪各个Region里面的垃圾垃圾堆积的大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许收集时间，优先回收价值最大的Region。保证了G1收集器在有效的时间内可以获取尽可能高的收集效率
  - 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好的多
- G1无论是垃圾收集产生的内存占用还是程序运行时的额外执行负载都要不CMS要高。从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其有时。平衡点在6-8G之间
- `-XX:+UseG1GC` ：手动指定使用G1收集器执行内存回收任务
- `-XX:G1HeapRegionSize`：设置每个Region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048各区域。默认是堆内存的1/2000
- `-XX:MaxGCPauseMillis`：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认是200ms
- `-XX:`ParallelGCThread：设置STW时GC线程数的值，最多设置为8
- `-XX:ConcGCThreads`：设置并发标记的线程数。将n设置为并行垃圾回收线程数的1/4左右
- `-XX:InitiatingHeapOccupanyPercent`：设置触发并发GC周期的Java堆占用率阈值。超过此值就触发GC。默认是45
- G1的设计原就是简化JVM性能调优，开发人员只需要简单三步即可完成调优：
  1. 开启G1垃圾收集器
  2. 设置堆的最大内存
  3. 设置最大停顿时间
- G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC,，在不同的条件下被触发

##### 13.3.6.1.Region：化整为零

- ![17](./images/17.png)

- 所有的Region大小相同，且在JVM生命周期内不会被改变，新生代和老年代物理上不连续
- humongous区域用来存放大对象，对象大小超过1.5个Region会被存放到该区域。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储 ，为了能找到合适的H区，有时会触发FULL GC
- 一个Region只能属于一个角色（Eden、survivor、old、humongous）
- Region内部采用指针碰撞，同时支持TLAB，为每个线程分配一个region

##### 13.3.6.2.G1回收器垃圾收集过程

- ![18](./images/18.png)

- 主要包含以下三个环节：
  - 年轻代GC（Young GC）
  - 老年代并发标记过程（Concurrent Marking）
  - 混合回收（Mixed GC）
  - 如果需要，单线程、独占式、高强度的FULL GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收
- 当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用线程，启动多线程执行年轻代垃圾回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能时两个区间都会涉及
- 当堆内存达到一定值（默认45%）时，开始老年代并发标记过程。
- 标记完成后马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成了老年代的一部分。和年轻代不同，老年代G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年的的Region就可以了。同时，这和老年代Region是和年轻代一起被回收的

##### 13.3.6.3.记忆集和写屏障

- 问题：
  - 一个对象被不同区域引用的问题
  - 一个Region不可能是孤立的，一个Region中的对象可能被其他Region中对象引用，在判断其对象存活时，是否需要扫描整个Java堆才能保证准确？
  - 在其他分代收集器，也存在这个问题（而G1更突出）
  - 回收新生代也不得不同时扫描老年代？
  - 这样的话会降低Minor GC的效率
- 解决方法：
  - 无论G1还是其他分代收集器，JVM都是使用Remembered Set（记忆集）来避免全局扫描
  - 每一个Region都有一个对应的Remembered Set
  - 每次Referencee类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作
  - 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）
  - 如果不同，通过CardTabel（卡表）把相关医用信息记录到引用指向对象所在Region对性的Remembered Set中
  - 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏



## 14.Class文件结构

- Java语言：跨平台的语言（write once, run anywhere）
  - 当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无需再次编译
  - 这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、List等有强大的解释器
  - 跨平台似乎已经快成为一门语言必选的特性

- Java虚拟机：跨语言的平台。Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上运行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁

- Class文件是一组以8字节为基础单位的二进制流。在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

- Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表

  - 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
  - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯地以`_info`结尾。表用于表述有层次关系的复合结构地数据。整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明。

- Class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但其基本结构和框架是非常稳定的。其总体结构如下：

  - 魔数
  - Class文件版本
  - 常量池
  - 访问标志
  - 类索引，父类索引，接口索引集合
  - 字段表集合
  - 方法表集合
  - 属性表集合

- | 类型           | 名称                | 说明                   | 长度    | 数量                  |
  | -------------- | ------------------- | ---------------------- | ------- | --------------------- |
  | u4             | magic               | 魔数,识别Class文件格式 | 4个字节 | 1                     |
  | u2             | minor_version       | 副版本号(小版本)       | 2个字节 | 1                     |
  | u2             | major_version       | 主版本号(大版本)       | 2个字节 | 1                     |
  | u2             | constant_pool_count | 常量池计数器           | 2个字节 | 1                     |
  | cp_info        | constant_pool       | 常量池表               | n个字节 | constant_pool_count-1 |
  | u2             | access_flags        | 访问标识               | 2个字节 | 1                     |
  | u2             | this_class          | 类索引                 | 2个字节 | 1                     |
  | u2             | super_class         | 父类索引               | 2个字节 | 1                     |
  | u2             | interfaces_count    | 接口计数器             | 2个字节 | 1                     |
  | u2             | interfaces          | 接口索引集合           | 2个字节 | interfaces_count      |
  | u2             | fields_count        | 字段计数器             | 2个字节 | 1                     |
  | field_info     | fields              | 字段表                 | n个字节 | fields_count          |
  | u2             | methods_count       | 方法计数器             | 2个字节 | 1                     |
  | method_info    | methods             | 方法表                 | n个字节 | methods_count         |
  | u2             | attributes_count    | 属性计数器             | 2个字节 | 1                     |
  | attribute_info | attributes          | 属性表                 | n个字节 | attributes_count      |

### 14.1.魔数

- 每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）
- 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符
- 魔数固定值为0xCAFEBABE。不会改变
- 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动

### 14.2.Class文件版本号

- 紧接着魔数的4个字节存储的是Class文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，第7个和第8个字节就是编译的主版本号major_version

- 他们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号就确定为M.m

- 版本号和Java编译器的关系如下表：

  - | 主版本（十进制） | 副版本（十进制） | 编译器版本 |
    | ---------------- | ---------------- | ---------- |
    | 45               | 3                | 1.1        |
    | 46               | 0                | 1.2        |
    | 47               | 0                | 1.3        |
    | 48               | 0                | 1.4        |
    | 49               | 0                | 1.5        |
    | 50               | 0                | 1.6        |
    | 51               | 0                | 1.7        |
    | 52               | 0                | 1.8        |
    | 53               | 0                | 1.9        |
    | 54               | 0                | 1.10       |
    | 55               | 0                | 1.11       |

- Java的版本号是从45开始的，JDK1.1之后的每一个版本大版本发布，主版本号向上加一

- 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件

- 在实际应用中，由于开发环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致

### 14.3.常量池

- 常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用
- 随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石。
- 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。
- 常量池中的常量的数量不是固定的，所以在常量池的入口放置一项u2类型的无符号数，代表常量池容量计数值。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的

#### 14.3.1.常量池计数器

- 由于常量池的数量不固定，所以需要放置两个字节来表示常量池容量计数值
- 常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count =1表示常量池中有0个常量项
  - 通常我们写代码时都是从0开始的，但是这里的常量却是从1开始，因为它把第0项空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可以用索引值0来表示

#### 14.3.2.常量池表中的字面量和符号引用

- 常量池主要存放两大类常量：字面量和符号引用
- ![20](./images/20.png)

- ![21](./images/21.png)

- 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第一个字节作为类型标记，用于确定该项的格式，这个字节成为tage byte（标记字节、标签字节）

- 字面量：主要是由文本字符串和声明为final的常量值组成

- 符号引用：主要包括：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符

  - 描述符：

    - | 标志符 | 含义                                                 |
      | ------ | ---------------------------------------------------- |
      | B      | 基本数据类型byte                                     |
      | C      | 基本数据类型char                                     |
      | D      | 基本数据类型double                                   |
      | F      | 基本数据类型float                                    |
      | I      | 基本数据类型int                                      |
      | J      | 基本数据类型long                                     |
      | S      | 基本数据类型short                                    |
      | Z      | 基本数据类型boolean                                  |
      | V      | 代表void类型                                         |
      | L      | 对象类型，比如：`Ljava/lang/Object;`                 |
      | [      | 数组类型，代表一维数组。比如：`double[][][] is [[[D` |

### 14.4.访问标识（access_flage）

- 在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等

  - | 标志名称       | 标志值 | 含义                                                         |
    | -------------- | ------ | ------------------------------------------------------------ |
    | ACC_PUBLIC     | 0x0001 | 标志为public类型                                             |
    | ACC_FINAL      | 0x0010 | 标志被声明为final，只有类可以设置                            |
    | ACC_SUPER      | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） |
    | ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                             |
    | ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |
    | ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） |
    | ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                             |
    | ACC_ENUM       | 0x4000 | 标志这是一个枚举                                             |

- 类的访问权限通常为ACC_开头的常量

- 使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记

### 14.5.类索引，父类索引，接口索引集合

- 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：

  - | 长度              | 含义                         |
    | ----------------- | ---------------------------- |
    | u2                | this_class                   |
    | u2                | super_class                  |
    | u2                | interfaces_count             |
    | 每个interface占u2 | interfaces[interfaces_count] |

- 这三项数据来确定这个类的继承关系

  - 类索引用于确定这个类的全限定类名
  - 父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了`java.lang.Object`之外，所有的Java类都有父类，因此除了Object类之外，所有的Java类的父类索引都不为0
  - 接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implements语句（如果这个类本身就是一个接口，则应当是extends语句）后的顺序从左到右排列在接口索引集合中

### 14.6.字段表集合

- 包含字段计数器（2个字节）和字段表（8+属性集合字节）

- fields（字段）：用于描述接口或类中生命的遍历。字段包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。

- 字段叫什么名字、字段被定义成什么类型，这些是无法固定的，只能引用常量池中的常量来描述，它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符、是类变量还量实例变量、是否常量等

- 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加只想外部类实例的字段

- 在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的

- fields_count（字段计数器）：表示当前class文件fields表的成员个数，使用两个字节来表示。fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括内部方法声明的变量，也不包括从父类接口继承的那些字段

- 字段表结构：

  - | 类型           | 名称              | 含义       | 数量             |
    | -------------- | ----------------- | ---------- | ---------------- |
    | u2             | access_flags      | 访问标志   | 1                |
    | u2             | name_index        | 字段名索引 | 1                |
    | u2             | description_index | 描述符索引 | 1                |
    | u2             | attributes_count  | 属性计数器 | 1                |
    | attribute_info | atrributes        | 属性集合   | attributes_count |

    - 访问标志：

      | 标志名称      | 标志值 | 含义                       |
      | ------------- | ------ | -------------------------- |
      | ACC_PUBLIC    | 0x0001 | 字段是否为public           |
      | ACC_PRIVATE   | 0x0002 | 字段是否为private          |
      | ACC_PROTECTED | 0x0004 | 字段是否为protected        |
      | ACC_STATIC    | 0x0008 | 字段是否为static           |
      | ACC_FINAL     | 0x0010 | 字段是否为final            |
      | ACC_VOLATILE  | 0x0040 | 字段是否为volatile         |
      | ACC_TRANSTENT | 0x0080 | 字段是否为transient        |
      | ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 |
      | ACC_ENUM      | 0x4000 | 字段是否为enum             |

    - 描述符指向常量池中的描述符
    - 一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性的个数存放在atrribute_count中，属性具体内容存放在atrributes数组中

### 14.7.方法表集合

- 由方法计数器（两个字节）和方法表组成

- methods：指向常量池索引集合，它完整描述了每个方法的签名

  - 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息，比如方法的访问修饰符、方法的返回值类型以及方法的参数信息等
  - 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来
  - 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（不如：类（接口）初始化方法`<clint>()`和实例初始化方法`<init>()`）

- methods_count（方法计数器）：表示当前class文件methods表的成员个数，占用两个字节

- methods[]（方法表）：方法表中每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个methods_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。

- methods_info结构可以表示类和接口中定义的所有方法，包括类方法、实例方法、实例初始化方法和类或接口初始化方法

- 方法表的结构实际是和字段表一致的：

  - | 类型           | 名称              | 含义       | 数量             |
    | -------------- | ----------------- | ---------- | ---------------- |
    | u2             | access_flags      | 访问标志   | 1                |
    | u2             | name_index        | 方法名索引 | 1                |
    | u2             | description_index | 描述符索引 | 1                |
    | u2             | attributes_count  | 属性计数器 | 1                |
    | attribute_info | atrributes        | 属性集合   | attributes_count |

- 方法表访问标志，与字段表访问标志相似：

  - | 标志名称      | 标志值 | 含义                                    |
    | ------------- | ------ | --------------------------------------- |
    | ACC_PUBLIC    | 0x0001 | public，方法可以从包外访问              |
    | ACC_PRIVATE   | 0x0002 | private，方法只能从本类中访问           |
    | ACC_PROTECTED | 0x0004 | protected，方法在自身和子类中都可以访问 |
    | ACC_STATIC    | 0x0008 | static，静态方法                        |
    | ACC_FINAL     | 0x0010 | 字段是否为final                         |
    | ACC_VOLATILE  | 0x0040 | 字段是否为volatile                      |
    | ACC_TRANSTENT | 0x0080 | 字段是否为transient                     |
    | ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生              |
    | ACC_ENUM      | 0x4000 | 字段是否为enum                          |

### 14.8.属性表集合

- 是由属性表长度+属性表组成

- 方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件名称。以及任何带有`RetentionPolicy.CLASS`或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解

- 此外，字段表、方法表都可以拥有自己的属性表。用于描述某些场景专有的信息。

- 属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性

- 属性通用格式：

  - | 类型 | 名称                 | 数量             | 含义       |
    | ---- | -------------------- | ---------------- | ---------- |
    | u2   | attribute_name_index | 1                | 属性名索引 |
    | u4   | attribute_length     | 1                | 属性长度   |
    | u1   | info                 | attribute_length | 属性表     |



## 15.字节码指令

- Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及随后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码
- 由于限制了Java虚拟机操作码的长度为一个字节（即0-255），这意味着指令集的操作码总数不可能超过256条
- 在Java虚拟机的指令集中，大多数的指令都包含了其操作数对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令则加载的是float类型的数据
- 对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为那种数据类型服务：
  - i代表对Int类型的数据操作
  - l代表long
  - s代表short
  - b代表byte
  - c代表char
  - f代表float
  - d代表double
- 也有一些指令的助记符没有明确地指明操作类型的字符，如arraylength指令，他没有代表数据类型的特殊字符，但操作数永远只能是一个数组对象，还有一些指令，如无条件跳转指令goto则是与数据类型无关的



### 15.1.加载和存储指令

- 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递
- 常用指令：
  - 局部变量压栈指令：将一个局部变量加载到操作数栈：`xload`、`xload_<n>`（其中x为i 、l、f、d、a，n为0-3）
  - 常量入栈指令：将一个常量加载到操作数栈：`bipush`、`sipush`、`ldc`、`ldc_w`、`ldc2_w`、`aconst_null`、`iconst_m1`、`iconst_<i>`、`lconst_<l>`、`fconst_<f>`、`dconst_<d>`
    - const：用于对特定常量的入栈，入栈的常量隐含在指令本身里。
      - `iconst_m1`：将数据-1压入操作数栈
      - `iconst_x`：(x取0到5)，将x压入操作数栈
      - `lconst_<l>`：（l取0和1），将长整数0和1压入操作数栈
      - `fconst_<f>`：（f取0到2）将浮点数0、1、2压入操作数栈
      - `dconst_<d>`：(d取0和1)，将double型0和1压入操作数栈
      - `aconst_null`：将null压入操作数栈
    - push：主要包括`bipush`和`sipush`。他们的区别在于接受的数据类型不同，`bipush`接收8位整数作为参数，`sipush`接收16位整数，它们都将压入操作数栈
    - ldc：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，他可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入栈
  - 出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：`xstore`、`xstrore_<n>`（i 、l、f、d、a，n为0-3）;`xstore`，其中x为i 、l、f、d、a、b、c、s
  - 扩充局部变量表的访问指令：`wide`

### 15.2.算术指令

- 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈
- 大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令
- 所有的算数指令包括：
  - 加法指令：`iadd`、`ladd`、`fadd`、`daad`
  - 减法指令：`isub`、`lsub`、`fsub`、`dsub`
  - 乘法指令：`imul`、`lmul`、`fmul`、`dmul`
  - 除法指令：`idiv`、`ldiv`、`fdiv`、`ddiv`
  - 求余指令：`irem`、`lrem`、`frem`、`drem` （remainder：余数）
  - 取反指令：`ineg`、`lneg`、`fneg`、`dneg`（negation：取反）
  - 自增指令：`iinc`
  - 位运算指令，又可分为：
    - 位移指令：`ishl`、`ishr`、`iushr`、`lshl`、`lshr`、`lushr`
    - 按位或指令：`ior`、`lor`
    - 按位与指令：`iand`、`land`
    - 按位异或指令：`ixor`、`lxor`
  - 比较指令：`dcmpg`、`dcmpl`、`fcmpg`、`fcmpl`、`lcmp`

### 15.3.类型转换指令

- 类型转换指令可以将两种不同的数值类型进行相互转换
- 这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题
- 宽化类型转换：Java虚拟机支持以下数值的宽化类型转换，简化为（int --> long --> float --> double）：
  - 从int类型到long、float或者double类型。对应的指令为：`i2l`、`i2f`、`i2d`
  - 从long类型到float、double类型。对应指令为：`l2f`、`l2d`
  - 从float类型到double类型。对应指令为：`f2d`
- 窄化类型转换
  - 从int类型至byte、short、char类型。对应指令有：`i2b`、`i2c`、`i2s`
  - 从long类型至int类型。对应指令：`l2i`
  - 从float类型到int或long类型。对应指令：`f2i`、`f2l`
  - 从double类型到int、long类型。对应指令：`d2i`、`d2l`

### 15.4.对象的创建与访问指令

- Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象进行了深层次的支持。有一系列的指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令
- 创建指令：虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与使用使用了不同的字节码指令：
  - 创建类实例的指令：`new`，它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈
  - 创建数组的指令：
    - `newarray`：创建基本类型数组
    - `anewarray`：创建引用类型数组
    - `multianewarray`：创建多维数组
- 字段访问指令：
  - 访问类字段（static字段，或者称为类变量）的指令：`getstatic`、`putstatic`
  - 访问类实例字段（非static字段，或者称为实例变量）的指令：`getfield`、`putfield`

- 数组操作指令主要有xastore和xaload指令。具体为：
  - 把一个数组元素加载到操作数栈的指令：`baload`、`caload`、`saload`、`iaload`、`iaload`、`laload`、`faload`、`daload`、`aaload`
  - 把一个操作数栈的值存储数组元素的指令：`bastore`、`castore`、`sastore`、`iastore`、`lastore`、`fastore`、`dastore`、`aastore`
  - 取数组长度指令：`arraylength`

- 类型检查指令：检查类实例或数组类型的指令：`instanceof`、`checkcast`。
  - 指令`checkcast`用于检查类型强制转换是否可以进行，如果可以进行，那么`checkcast`指令不会改变操作数栈，否则它会抛出ClassCastException异常
  - 指令`instanceof`用来判读给定对象是否是某一个类的实例，它会将判断结果压入操作数栈

### 15.5.方法调用与返回指令

- 方法调用指令：
  - `invokevirtual`指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分配方式
  - `invokeinterface`指令用于调用接口方法，他会在运行时搜索由特定对象实现的这个接口方法，并找出适合的方法调用
  - `invokespecial`指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发
  - `invokestatic`指令用于调用命名类中的类方法（static方法）。这是静态绑定的
  - `invokedynamic`：调用动态绑定的方法，这个是JDK1.7后新加入的指令，用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在java虚拟机内部，而`invokedynamic`指令的分派逻辑是由用户所设定的引导方法决定的
- 方法返回指令：方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型进行区分的。
  - 有返回值的方法返回指令：`ireturn`（当返回值是boolean、byte、char、short和int类型时使用）、`ireturn`、`lreturn`、`freturn`、`dreturn`、`areturn`
  - 没有返回值的方法返回指令：`return`，供声明为void方法、实例初始化方法以及类和接口的初始化方法使用

### 15.6.操作数栈管理指令

- 如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。这类指令包含如下内容：
  - 将一个或两个元素（指的是Slot）从栈顶弹出，并且直接废弃：`pop`、`pop2`
  - 复制栈顶一个或两个数值（指的是Slot）并将复制值或双份的复制值重新压入栈顶：`dup`、`dup2`、`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`
    - `dup`指复制一个Slot，`dup2`指复制两个Slot
    - `dupa_xb`是指复制栈顶的a个元素，插入到距栈顶(a + b)个元素的位置
  - 将栈最顶端的两个Slot数值位置交换：`swap`。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令
  - 指令`nop`，这是一个非常特殊的指令，它的字节码是0x00，和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等

### 15.7.控制转移指令

- 条件跳转指令：条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的预备，然后进行条件跳转。条件跳转指令有：`ifeq`、`iflt`、`ifle`、`ifne`、`ifge`、`ifnull`、`ifnonnull`。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。他们统一的含义是：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。

  - | 指令      | 含义                             |
    | --------- | -------------------------------- |
    | ifeq      | 当栈顶int类型数值等于0时跳转     |
    | ifne      | 当栈顶int类型数值不等于0时跳转   |
    | iflt      | 当栈顶int类型数值小于0时跳转     |
    | ifle      | 当栈顶int类型数值小于等于0时跳转 |
    | ifgt      | 当栈顶int类型数值大于0时跳转     |
    | ifge      | 当栈顶int类型数值大于等于0时跳转 |
    | ifnull    | 为null时跳转                     |
    | ifnonnull | 不为null时跳转                   |

- 比较条件跳转指令：比较跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。具体的条件跳转指令有：`if_icmpeq`、`if_icmpne`、`if_icmplt`、`if_icmpgt`、`if_icmple`、`if_icmpge`、`if_acmpeq`、`if_acmpne`

  - | 指令      | 含义                                                |
    | --------- | --------------------------------------------------- |
    | if_icmpeq | 比较栈顶两int类型数值大小，当前者等于后者时跳转     |
    | if_icmpne | 比较栈顶两int类型数值大小，当前者不等于后者时跳转   |
    | if_icmplt | 比较栈顶两int类型数值大小，当前者小于后者时跳转     |
    | if_icmple | 比较栈顶两int类型数值大小，当前者小于等于后者时跳转 |
    | if_icmpgt | 比较栈顶两int类型数值大小，当前者大于后者时跳转     |
    | if_icmpge | 比较栈顶两int类型数值大小，当前者大于等于后者时跳转 |
    | if_acmpeq | 比较栈顶两引用类型数值，当结果相等时跳转            |
    | if_acmpne | 比较栈顶两引用类型数值，当结果不相等时跳转          |

- 多条件分支跳转指令：多条件分支跳转指令是专门为switch-case语句设计的，主要有`tableswitch`和`loopupswitch`

  - `tableswitch`要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高
  - `loopupswitch`内部存放着各个离散的case-offset对，每次执行要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率低

- 无条件跳转指令：目前主要的无条件跳转指令为`goto`，该指令接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。如果指令偏移量太大，超过了双字节带符号整数的范围，则可以使用指令`goto_w`，它和`goto`有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。`jsr`、`jsr_w`、`ret`虽然也是无条件跳转的，但是主要用于try-finally语句，且已被虚拟机逐渐废弃

### 15.8.异常处理指令

- 在Java程序中显式抛出异常的操作（throw语句）都是由`athrow`指令来实现。除了使用throw语句显式抛出异常，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。正常情况下，操作数栈的压入和弹出都是一条条指定完成的，唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，然后将异常实例压入到调用者操作数栈上
- 在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用`jsr`、`ret`指令）,而是采用异常表来完成的
- 异常表：如果一份方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：
  - 起始位置
  - 结束位置
  - 程序计数器记录代码处理的偏移地址
  - 被捕获的异常类在常量池中的索引
- 当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用发方法栈帧）。如果在所有栈帧弹出前仍然没有合适的异常处理，这个线程将种植。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程时main线程
- 不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标

### 15.9.同步控制指令

- Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用`monitor`来支持的
- 方法级的同步：是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志的得知一个方法是否为同步方法
- 在调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置
  - 如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
  - 在方法执行期间，执行线程持有了同步锁，其他任何线程都无法在获得同一个锁
  - 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个方法所持有的锁将在异常抛出到同步方法之外时释放
- 同步一段指令集序列：通常是由java中的synchoronized语句块来表示的。jvm的指令集有`monitorenter`和`monitorexit`两条指令来支持synchronized关键字的含义。当一个线程进入同步代码块时，它使用`monitorenter`指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象监视器计数器为0，才会被允许进入代码块。当线程退出同步块时，需要使用`monitorexit`指令声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。指令`monitorenter`和`monitorexit`在执行时，都需要在操作数栈顶压入对象，之后`monitorenter`和`monitorexit`的锁定和释放都是针对这个对象的监视器进行的



