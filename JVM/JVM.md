# JVM学习笔记

## 1.概述

-  JVM是直接运行在操作系统上的，它与硬件没有直接的交互
  - java代码 -> 字节码文件 -> JVM  -> 操作系统
  - 高级语言执行顺序：高级语言 -> 汇编语言 -> 机器指令 -> CPU

- JVM整体结构：
  - ![1](.\images\1.png)
  - 多个线程共享方法区和堆，java栈（现在叫虚拟机栈）、本机方法栈、程序计数器是每个线程独有的
-  Java编译器输入的指令流基本上是一种基于**栈的指令集架构**，另一种指令集架构则是基于**寄存器的指令集架构**
  - 基于栈的指令集架构，指令集小（8位）但具体的指令多；基于寄存器的指令集架构，指令集大（16位）但具体的指令少
  - 基于栈的指令集结构是基于内存的，对硬件依赖较小，可以跨平台，但是性能会有所下降；基于寄存器的指令集结构是基于寄存器的，与硬件耦合性较高，性能较高
- JVM的生命周期：
  - 启动：通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。
  - 执行：
    - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
    - 程序开始执行时他才运行，程序结束时他就停止
    - 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程
  - 退出
    - 程序正常执行结束
    - 程序在执行的过程中遇到了异常或错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止
    - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
    - 除此之外，JNI (Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟退出的情况
- JVM发展历程：
  - Sun Classic VM：世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰，这款虚拟机内部只提供解释器，如果使用JIT编译器，就需要外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作。现在hotspot内置了此虚拟机
  - Exact VM：JDK1.2时。sun提供了此虚拟机，可以知道内存中某个位置的数据具体是什么类型。使用热点探测技术，采用编译器和解释器混合工作模式
  - **HotSpot** VM：JDK和OpenJdk的默认虚拟机，HotSpot 意思是指采用热点代码探测技术
  - **JRockit**：专注于服务器应用，不包含解释器实现，世界上最快的JVM，JDK8将一些功能整合至HotSpot上
  - **J9**：和HotSpot，JRockit并列为三大商用虚拟机，广泛用于IBM的各种Java产品
  - KVM和CDC/ CLDC HotSpot：KVM时CLDC-HI早期产品，面向更低端设备；CDC和CLDC HotSpot主要是Oracle用在JAVAE ME产品线上的虚拟机
  - Azul VM和BEA Liquid VM：与特定硬件平台绑定、软硬件配合的专有虚拟机
  - Apache Harmony：兼容JDK 1.5H和1.6，IBM和Intel联合开发的开源JVM，它的Java类库代码吸纳进了Android SDK
  - Microsoft JVM：微软为了在IE3浏览器中支持JAVA Applets，只能在window平台下运行，当时Windows下性能最好的Java VM
  - TaobaoJVM：基于OpenJDK开发的，深度定制且开源的高性能服务器版Java虚拟机，硬件严重依赖intel的cpu，将生命周期的对象从堆中移至堆中，降低GC开销，对象能够在多个Java虚拟机进程中实现共享
  - Dalvik VM：谷歌开发的应用与Android系统的虚拟机，没有遵循Java虚拟机规范，基于寄存器架构，Android 5.0使用支持提前编译的ART VM替换Dalvik VM
  - Graal VM：在HotSopt VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用

## 2.类加载子系统

- 主要步骤：Loading -> Linking -> Initialization即 加载->链接->初始化
  - ![2](.\images\2.png)
- 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识
- ClssLoader只负责class文件的加载，至于它是否可以运行，则有Execution Engine巨顶
- 加载的类信息存放于一块成为方法区的内容空间。除了类信息外，方法区中还会包含存放运行时常量池信息，可能还包括字符串字面量和数字厂里（这部分常量信息是Class文件中常量池部分的内存映射）

### 2.1.Loading（加载）

- 加载的顺序：
  - 通过一个类的全限定名获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据访问入口
- 加载.class文件可以从本地系统、网络、zip压缩包、运行时计算生成（动态代理）、由其他文件生成（JSP）、专有数据库中提取、从加密文件中获取（防止被反编译）

### 2.2.Linking（链接）

- 验证(verify)：确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包含：文件格式验证、元数据验证、字节码验证、符号引用验证四种方式。
  - JAVA虚拟机字节码文件开头: KA FE BA BE
- 准备(prepare)：为类变量（静态变量）分配内存并设置该类变量的值为默认初始值
  - 不包含final修饰的static，因为final修饰的变量被看作常量，在编译时就会分配初始值了，准备阶段会显示初始化
  - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到JAVA堆中
- 解析(resolve)：将常量池内的符号引用转换为直接引用的过程
  - 事实上解析操作往往会在JVM初始化之后再执行
  - **符号引用**以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中
  - **直接引用**可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已在内存中存在

### 2.3.Initialization（初始化）

- 初始化阶段就是执行类构造器方法`<clinit>()`的给过程
  - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的复制动作和静态代码块中的语句合并而来
  - 构造器方法中指令按语句在 源文件中出现的顺序执行
  - `<clinit>()`不同于类的构造器
  - 若该类具有父类，jvm会保证父类的`<clinit>()`方法执行完毕后在执行该类的`<clinit>()`方法
  - 虚拟机保证一个类的`<clinit>()`方法在多线程下被同步加锁
  - 如果类中没静态变量、静态代码块，则不会有`<clinit>()`方法

### 2.4.类的加载器分类

- JVM支持两种类型的类的加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这样定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
- 无论类加载器类型如何划分，在程序中我们最常见的类加载器始终只有3个：
  - ![3](.\images\3.png)

#### 2.4.1.启动类加载器（BootStrap CLassLoader）

- 这个类加载使用C/C++语音实现的，嵌套在JVM内部
- 它用来加载Java的核心库，用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
- 出于安全考虑，该启动类加载器只加载包名为java、javax、sun等开头的类

#### 2.4.2.扩展类加载器（Extension ClassLoader）

- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
- 派生于ClassLoader类
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性指所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载该类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

#### 2.4.3.应用程序类加载器（系统类加载器，AppClassLoader）

- Java语言编写，由sun.misc.Launcher$AppClassLoader实现
- 派生于ClassLoader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
- 可以通过`ClassLoader.getSystemClassLoader()`方法获取到该类加载器

#### 2.4.4.用户自定义类加载器（User-Defined ClassLoader）

- 使用场景：
  - 隔离加载类（隔离依赖环境，避免类冲突）
  - 修改类加载的方式
  - 扩展加载源
  - 防止源码泄露
- 用户自定义类加载器实现步骤
  - 通过继承抽象类java.lang.ClassLoader，实现自己的类加载器，以满足一些特殊的需求
  - JDK1.2之前通过重写继承的CLassLoader类的`loadClass()`方法，实现自定义的类加载类，JDK1.2之后已不再建议用户覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中
  - 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写`findClass()`方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

### 2.5.双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时，才会将它的class文件加载到内存生成class对象。二七加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式

![4](.\images\4.png)

- 工作原理
  1. 如果一个类的加载器收到了类加载请求，它不会先自己去加载，而是把这个请求委托给父类的加载器去执行
  2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归直到启动类加载器
  3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会自己尝试去加载
- 沙箱安全机制： 保护核心代码，防止由引导类加载器加载的核心类被污染



## 3.程序计数器（PC寄存器）

- PC寄存器用来存储指向下一条指令的地址，只占用很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
- 每个线程都会有各自的程序计数器，生命周期与线程保持一致
- 任何时间一个线程都只会有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前正在执行的Java方法的JVM指令地址。如果是在执行native方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成
- 字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域
- 通过PC寄存器，就可以在线程切换回来后，能够从上次暂停的地方继续执行
- cpu计数器概念：为了保证程序（在操作系统中理解为进程）能够连续地执行下去，处理器必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的内存单元地址送入程序计数器，因此程序计数器的内容即是从内存提取的一条指令的地址。当执行指令时，处理器将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。但是，当遇到转移指令如JMP（跳转、外语全称：JUMP）指令时，后继指令的地址（即PC的内容）必须从指令寄存器中的地址字段取得。在这种情况下，下一条从内存取出的指令将由转移指令来规定，而不像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存信息和计数两种功能的结构。



## 4.虚拟机栈

- 由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的
- 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令
- 栈是运行时的单位，堆是存储的单位
- 每个线程都会有各自的虚拟机栈，生命周期与线程保持一致。其内部保存的单位是栈帧，对应着一次次的Java方法调用
- 主管Java程序的运行，他保存方法的局部变量、部分结果，并参与方法的调用和返回，不存在GC，存在OOM
- 访问速度仅次于程序计数器，JVM对于Java栈的操作只有两个
  - 每个方法执行，伴随着进栈
  - 执行结束后的出栈工作
- 栈的大小可以设置为动态变化的，也可以设置为固定不变的。动态情况下，容量不足扩容无法申请到空间时会抛出OOM；固定情况下容量不足会抛出StackOverflow
- `-Xss `参数设置栈最大空间

### 4.1.栈的基本结构及运行原理

- 线程上正在执行的每个方法都各自对应一个栈帧
- 栈帧时一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧，只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，当前栈帧对应的方法时当前方法，定义这个方法的类就是当前类
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来放在栈的顶端，成为新的当前栈帧
- 如果当前方法被是被其他方法调用的，方法返回之际，当前栈帧会传回此方法的结果给前一个栈帧（前面所提到的其他方法），接着虚拟机会丢弃当前栈帧（出栈），使得前一个栈帧成为新的当前栈帧
- Java方法有两种返回函数的方式，一种是正常返回（return），另外一种时抛出异常，不管使用那种方式，都会使栈帧被弹出

### 4.2.栈帧内部结构

每个栈帧存储着以下五部分：

1. 局部变量表（Local Variables）
2. 操作数栈 （Operand Stack）（或表达式栈）
3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
4. 方法返回地址 （Return Address）（或方法正常退出或异常退出的定义）
5. 一些附加信息

#### 4.2.1.局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用以及returnAddress类型
- 因为是建立在栈上，所以不存在线程间的数据安全问题
- 局部变量表的所需容量大小是在编译期确定下来的，并保存在Code属性的maximum local variables数据项中，在方法运行期是不会改变局部变量表的大小的
- 对于一个函数而言，它的参数和局部方法越多，局部变量表就会越大，它对应的栈帧也会越大。当栈帧被销毁时，局部变量表也会被销毁