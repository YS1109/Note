# JVM学习笔记

## 1.概述

-  JVM是直接运行在操作系统上的，它与硬件没有直接的交互
  - java代码 -> 字节码文件 -> JVM  -> 操作系统
  - 高级语言执行顺序：高级语言 -> 汇编语言 -> 机器指令 -> CPU

- JVM整体结构：
  - ![1](.\images\1.png)
  - 多个线程共享方法区和堆，java栈（现在叫虚拟机栈）、本机方法栈、程序计数器是每个线程独有的
-  Java编译器输入的指令流基本上是一种基于**栈的指令集架构**，另一种指令集架构则是基于**寄存器的指令集架构**
  - 基于栈的指令集架构，指令集小（8位）但具体的指令多；基于寄存器的指令集架构，指令集大（16位）但具体的指令少
  - 基于栈的指令集结构是基于内存的，对硬件依赖较小，可以跨平台，但是性能会有所下降；基于寄存器的指令集结构是基于寄存器的，与硬件耦合性较高，性能较高
- JVM的生命周期：
  - 启动：通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。
  - 执行：
    - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
    - 程序开始执行时他才运行，程序结束时他就停止
    - 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程
  - 退出
    - 程序正常执行结束
    - 程序在执行的过程中遇到了异常或错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止
    - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
    - 除此之外，JNI (Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟退出的情况
- JVM发展历程：
  - Sun Classic VM：世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰，这款虚拟机内部只提供解释器，如果使用JIT编译器，就需要外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作。现在hotspot内置了此虚拟机
  - Exact VM：JDK1.2时。sun提供了此虚拟机，可以知道内存中某个位置的数据具体是什么类型。使用热点探测技术，采用编译器和解释器混合工作模式
  - **HotSpot** VM：JDK和OpenJdk的默认虚拟机，HotSpot 意思是指采用热点代码探测技术
  - **JRockit**：专注于服务器应用，不包含解释器实现，世界上最快的JVM，JDK8将一些功能整合至HotSpot上
  - **J9**：和HotSpot，JRockit并列为三大商用虚拟机，广泛用于IBM的各种Java产品
  - KVM和CDC/ CLDC HotSpot：KVM时CLDC-HI早期产品，面向更低端设备；CDC和CLDC HotSpot主要是Oracle用在JAVAE ME产品线上的虚拟机
  - Azul VM和BEA Liquid VM：与特定硬件平台绑定、软硬件配合的专有虚拟机
  - Apache Harmony：兼容JDK 1.5H和1.6，IBM和Intel联合开发的开源JVM，它的Java类库代码吸纳进了Android SDK
  - Microsoft JVM：微软为了在IE3浏览器中支持JAVA Applets，只能在window平台下运行，当时Windows下性能最好的Java VM
  - TaobaoJVM：基于OpenJDK开发的，深度定制且开源的高性能服务器版Java虚拟机，硬件严重依赖intel的cpu，将生命周期的对象从堆中移至堆中，降低GC开销，对象能够在多个Java虚拟机进程中实现共享
  - Dalvik VM：谷歌开发的应用与Android系统的虚拟机，没有遵循Java虚拟机规范，基于寄存器架构，Android 5.0使用支持提前编译的ART VM替换Dalvik VM
  - Graal VM：在HotSopt VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用

## 2.类加载子系统

- 主要步骤：Loading -> Linking -> Initialization即 加载->链接->初始化
  - ![2](.\images\2.png)
- 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识
- ClssLoader只负责class文件的加载，至于它是否可以运行，则有Execution Engine巨顶
- 加载的类信息存放于一块成为方法区的内容空间。除了类信息外，方法区中还会包含存放运行时常量池信息，可能还包括字符串字面量和数字厂里（这部分常量信息是Class文件中常量池部分的内存映射）

### 2.1.Loading（加载）

- 加载的顺序：
  - 通过一个类的全限定名获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据访问入口
- 加载.class文件可以从本地系统、网络、zip压缩包、运行时计算生成（动态代理）、由其他文件生成（JSP）、专有数据库中提取、从加密文件中获取（防止被反编译）

### 2.2.Linking（链接）

- 验证(verify)：确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包含：文件格式验证、元数据验证、字节码验证、符号引用验证四种方式。
  - JAVA虚拟机字节码文件开头: KA FE BA BE
- 准备(prepare)：为类变量（静态变量）分配内存并设置该类变量的值为默认初始值
  - 不包含final修饰的static，因为final修饰的变量被看作常量，在编译时就会分配初始值了，准备阶段会显示初始化
  - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到JAVA堆中
- 解析(resolve)：将常量池内的符号引用转换为直接引用的过程
  - 事实上解析操作往往会在JVM初始化之后再执行
  - **符号引用**以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中
  - **直接引用**可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已在内存中存在

### 2.3.Initialization（初始化）

- 初始化阶段就是执行类构造器方法`<clinit>()`的给过程
  - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的复制动作和静态代码块中的语句合并而来
  - 构造器方法中指令按语句在 源文件中出现的顺序执行
  - `<clinit>()`不同于类的构造器
  - 若该类具有父类，jvm会保证父类的`<clinit>()`方法执行完毕后在执行该类的`<clinit>()`方法
  - 虚拟机保证一个类的`<clinit>()`方法在多线程下被同步加锁
  - 如果类中没静态变量、静态代码块，则不会有`<clinit>()`方法

### 2.4.类的加载器分类

- JVM支持两种类型的类的加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这样定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
- 无论类加载器类型如何划分，在程序中我们最常见的类加载器始终只有3个：
  - ![3](.\images\3.png)

#### 2.4.1.启动类加载器（BootStrap CLassLoader）

- 这个类加载使用C/C++语音实现的，嵌套在JVM内部
- 它用来加载Java的核心库，用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
- 出于安全考虑，该启动类加载器只加载包名为java、javax、sun等开头的类

#### 2.4.2.扩展类加载器（Extension ClassLoader）

- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
- 派生于ClassLoader类
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性指所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载该类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

#### 2.4.3.应用程序类加载器（系统类加载器，AppClassLoader）

- Java语言编写，由sun.misc.Launcher$AppClassLoader实现
- 派生于ClassLoader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
- 可以通过`ClassLoader.getSystemClassLoader()`方法获取到该类加载器

#### 2.4.4.用户自定义类加载器（User-Defined ClassLoader）

- 使用场景：
  - 隔离加载类（隔离依赖环境，避免类冲突）
  - 修改类加载的方式
  - 扩展加载源
  - 防止源码泄露
- 用户自定义类加载器实现步骤
  - 通过继承抽象类java.lang.ClassLoader，实现自己的类加载器，以满足一些特殊的需求
  - JDK1.2之前通过重写继承的CLassLoader类的`loadClass()`方法，实现自定义的类加载类，JDK1.2之后已不再建议用户覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中
  - 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写`findClass()`方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

### 2.5.双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时，才会将它的class文件加载到内存生成class对象。二七加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式

![4](.\images\4.png)

- 工作原理
  1. 如果一个类的加载器收到了类加载请求，它不会先自己去加载，而是把这个请求委托给父类的加载器去执行
  2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归直到启动类加载器
  3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会自己尝试去加载
- 沙箱安全机制： 保护核心代码，防止由引导类加载器加载的核心类被污染



## 3.程序计数器（PC寄存器）

- PC寄存器用来存储指向下一条指令的地址，只占用很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
- 每个线程都会有各自的程序计数器，生命周期与线程保持一致
- 任何时间一个线程都只会有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前正在执行的Java方法的JVM指令地址。如果是在执行native方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成
- 字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域
- 通过PC寄存器，就可以在线程切换回来后，能够从上次暂停的地方继续执行
- cpu计数器概念：为了保证程序（在操作系统中理解为进程）能够连续地执行下去，处理器必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的内存单元地址送入程序计数器，因此程序计数器的内容即是从内存提取的一条指令的地址。当执行指令时，处理器将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。但是，当遇到转移指令如JMP（跳转、外语全称：JUMP）指令时，后继指令的地址（即PC的内容）必须从指令寄存器中的地址字段取得。在这种情况下，下一条从内存取出的指令将由转移指令来规定，而不像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存信息和计数两种功能的结构。



## 4.虚拟机栈

- 由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的
- 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令
- 栈是运行时的单位，堆是存储的单位
- 每个线程都会有各自的虚拟机栈，生命周期与线程保持一致。其内部保存的单位是栈帧，对应着一次次的Java方法调用
- 主管Java程序的运行，他保存方法的局部变量、部分结果，并参与方法的调用和返回，不存在GC，存在OOM
- 访问速度仅次于程序计数器，JVM对于Java栈的操作只有两个
  - 每个方法执行，伴随着进栈
  - 执行结束后的出栈工作
- 栈的大小可以设置为动态变化的，也可以设置为固定不变的。动态情况下，容量不足扩容无法申请到空间时会抛出OOM；固定情况下容量不足会抛出StackOverflow
- `-Xss `参数设置栈最大空间
- 栈顶缓存技术：将栈顶元素全部缓存在物理的cpu的寄存器中，以此降低对对内存的IO次数，提升执行引擎的执行效率

### 4.1.栈的基本结构及运行原理

- 线程上正在执行的每个方法都各自对应一个栈帧
- 栈帧时一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧，只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，当前栈帧对应的方法时当前方法，定义这个方法的类就是当前类
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来放在栈的顶端，成为新的当前栈帧
- 如果当前方法被是被其他方法调用的，方法返回之际，当前栈帧会传回此方法的结果给前一个栈帧（前面所提到的其他方法），接着虚拟机会丢弃当前栈帧（出栈），使得前一个栈帧成为新的当前栈帧
- Java方法有两种返回函数的方式，一种是正常返回（return），另外一种时抛出异常，不管使用那种方式，都会使栈帧被弹出

### 4.2.栈帧内部结构

每个栈帧存储着以下五部分：

1. 局部变量表（Local Variables）
2. 操作数栈 （Operand Stack）（或表达式栈）
3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
4. 方法返回地址 （Return Address）（或方法正常退出或异常退出的定义）
5. 一些附加信息

其中方法返回地址、动态链接和一些附加信息成为帧数据区

#### 4.2.1.局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型（referemce）、对象引用以及returnAddress类型
- 因为是建立在栈上，所以不存在线程间的数据安全问题
- 局部变量表的所需容量大小是在编译期确定下来的，并保存在Code属性的maximum local variables数据项中，在方法运行期是不会改变局部变量表的大小的
- 对于一个函数而言，它的参数和局部方法越多，局部变量表就会越大，它对应的栈帧也会越大。当栈帧被销毁时，局部变量表也会被销毁
- 参数值的存放总是在局部变量表的index0开始，到`数组长度-1`的索引结束。局部变量表最基本的存储单元时Slot（变量槽）
- 32位的数据类型只占用一个Slot，64位的类型（long和double）占用两个slot。byte、short、char、boolean在存储前被转换为int
- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
- 如果当前帧是由构造方法或者实例方法（非静态方法）创建的，那么该对象引用this将会存放在index为0的slot处，其余参数按照参数表顺序继续排列 
- 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收

#### 4.2.2.操作数栈

- 操作数栈是使用数组实现的。`Java虚拟机的解释引擎是基于栈的执行引擎`，其中的栈指定就是操作数栈
- 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈帧是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值
- 栈中的任何一个元素都可以是任意的Java数据类型，32bit的类型占用一个栈深度，64bit的类型占用两个栈深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
- 如果当前方法是被其他方法抵用的其拥有返回值，则当前方法执行结束后，当前方法的返回值会被压入新的当前方法的操作数栈中，并且更新程序计数器中下一条需要执行的字节码指令

#### 4.2.3.动态链接

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用存放在栈帧的动态链接区域。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的方法是，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

#### 4.2.4.方法的调用

- 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关
  - 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期内可知，且运行时保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
  - 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称之为动态链接
- 对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类符号在符号引用被替换为直接引用的过程，这仅仅发生一次。因为面向对象的语言都具备多态的特性，所以自然也具备早期绑定和晚期绑定两种方式
  - 早期绑定：被调用的目标方法如果在编译期可知，且运行时保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用
  - 晚期绑定：如果被调用的方法在编译期无法被确定下来，只能在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定，对应动态链接
- 虚方法和非虚方法：和早期绑定对应的方法称为非虚方法，一般有：静态方法、私有方法、final方法、实例构造器和父类方法；其他方法为非虚方法，与动态连接绑定
- 方法重写的本质：
  1. 找到操作数栈顶的第一个元素所执行的对象实际类型，记作C
  2. 如果在类型C中找到与常量中的描述符合、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lamg.IllegalaAccessError异常
  3. 否则，按照继承关系从下往上以此对C的各个父类进行第2步的搜索和验证过程
  4. 如果没有找到合适的方法，则抛出java.lamg.IllegalaAccessError异常
- 在面向对象的编程中，会很频繁的使用到动态分派（虚方法引用），如果在每次动态分派的过程中都需要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率。因此为了提高性能，JVM采用了在类的方法区建立一个虚方法表来实现。使用索引表来代替查找。
  - 每一个类中都有一个虚方法表，表中存放着各个方法的实际入口
  - 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕

####  4.2.5.方法返回地址

- 存放调用该方法的pc寄存器的值
- 一个方法的结束有两种方式：正常执行完成和出现未处理的异常导致非正常退出
- 无论通过那种方式退出，在方法推出后都是返回到该方法的被调用的位置，方法正常退出后，叫调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常推出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

## 5.本地方法接口

- 一个Native Method就是一个Java调用非Java代码的接口。该方法的实现由非Java语言实现
- Java应用有时需要与Java外面的环境交互，这是本地方法存在的主要原因
- 通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一部分就是用C写的
- Sun的解释器使用C实现的，这使得它能像一些普通的C一样与外部交互



## 6.本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
- 允许被实现成固定大小和可动态扩展的内存大小（内存溢出方面和虚拟机栈相同）
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存
- 并不是所有的JVM都支持本地方法，因为Java虚拟机规范没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈
- 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一



## 7.堆

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
- Java堆区在JVM启动的时候被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间，它的大小也是可以调节的
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区
- 《Java虚拟机规范》中堆Java的描述是：所有的对象实例以及数组都应当在运行时分配在堆上，数组和对象可能永远不会存储在栈上，栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。（由例外情况，对象实例和数组可能存储在栈中）
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
- 堆是GC执行垃圾回收的重点区域
- 现代垃圾收集器大部分都基于分代收集理论设计
  - Java 7及之前的内存逻辑上分为三部分：新生区+养老区+永久区
  - Java及以后堆内存逻辑上分为：新生区+养老区+元空间
  - ![5](.\images\5.png)

- 只要是对象实例必然会在Java堆中分配

### 7.1.堆空间大小设置

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设计好了，可以通过`-Xmx`和`Xms`进行设置
  - `-Xms`用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`
  - `-Xmx`则用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`
- 一旦堆区中的内存超过`-Xmx`所指定的最大内存时，则会抛出OOM异常
- 默认情况下，`-Xms`为电脑物理内存的1/64，`-Xmx`为电脑物理内存的1/4



### 7.2.年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类：
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期非常长，在某些极端情况下还能够与JVM的生命周期保持一致
- Java堆区进一步细分的话可以划分为年轻代和老年代
- 其中年轻代又可划分为Eden空间、Survivor0空间和Survivor1空间（也叫from区和to区）
- ![6](.\images\6.png)
- 配置新生代和老年代在对接口的占比：
  - 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改`-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1，可以通过`-XX:SurvivorRation`调整这个空间比例，默认是有自适应的内存分配机制，必须由显式指令指定才会是8：1：1
- 几乎所有的Java对象都是在Eden区被new出来的
- 绝大部分的Java对象的销毁都在新生代进行了
- 可以使用选项`-Xmn`设置新生代最大内存大小，优先级高于`-XX:NewRatio=2`

### 7.3.对象分配过程

- new的对象优先放在伊甸区，此区大小有限制
- 伊甸区空间首次被填满时，会对伊甸区进行判断，将没有被引用的对象进行销毁，将剩余的对象移动至from区；如果非首次填满时，会同时对伊甸区和from区进行判断，销毁没有被引用的对象，将伊甸区和from区的对象移动至to区。然后再在伊甸区创建新的对象，按照这样的逻辑进行重复。这个过程称为YGC（Young GC）或Minor GC，每经历过一次GC，对象的年龄计数器就会加一
- 默认15次没有回收掉会被移动到老年区，可以通过参数修改：`-XX:MaxTenuringThreshold=<N>`来设置
- 幸存者区满时不会触发YGC，会有可能直接晋升至老年代
- 垃圾回收频繁发生在年轻代，很少在老年代发生，几乎不在永久区/元数据区发生
- ![7](.\images\7.png)
- JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分回收都发生在新生代，针对于HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集，一种是整堆收集
  - 部分收集：不是完整收集整合Java堆的垃圾收集，其中又分为：
    - 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集
    - 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集
      - 目前，只有CMS GC会有单独收集老年代的行为
      - 很多时候Major GC回合Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收

    - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
      - 目前，只有G1 GC会有这种行为

  - 整堆收集（FULL GC）：收集整个java堆和方法区的垃圾收集

- YGC触发机制：
  - 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发GC
  - 因为Java对象大多都具备朝生夕灭的特性，所以YGC非常频繁，一般回收速度也比较快。
  - Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行

- 老年代GC（Major GC / Full GC）触发机制：
  - 指发生在老年代的GC，出现了Major GC时，经常会伴随至少一次的YGC（但并非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）
    - 也就是是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

  - Major GC的速度一般会比YGC慢10倍以上，STW的时间更长
  - 如果Major GC后内存还不足，就会发生OOM

- Full GC触发机制：
  - 调用System.gc()时
  - 老年代空间不足时
  - 方法区空间不足
  - 通过YGC后进入老年代的平均大小大于老年代的可用内存
  - 有Eden区、from区向to区复制时，对象大小大于to区可用内存，则把该对象转为老年代，且老年代的可用内存大小小于该对象的大小


### 7.4.内存分配策略

- 针对不同年龄段的对象分配原则如下所示：
  - 优先分配到Eden
  - 大对象直接分配到老年代
  - 长期存活的对象分配到老年代
  - 动态对象年龄判断
    - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
  - 空间分配担保：`-XX:HadnlePromotionFailure`

### 7.5.TLAB

- TLAB：Thread Loacl Allocation Buffer
- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要使用加锁等机制，进而印象分配速度
- 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略
- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
- 可以通过`-XX:UserTLAB`来控制是否开启TLAB空间
- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，可以通过`-XX:TLABWasteTargetPercent`设置TLAB空间所占Eden空间的百分比大小
- 一旦对象在TLAB空间分配失败时，JVM就会尝试使用加速机制确保数据操作的原子性，从而直接在Eden空间中分配内存

### 7.6.常用参数

[官网说明](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)

- -XX:+PrintFlagsInitial：查看所有的参数的默认初始值

- -XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）

  > 具体查看某个参数的命令行指令：
  >
  > - jps：查看当前运行中的进程
  > - jinfo -flag SurvivorRatio 进程id

- -Xms：初始堆空间内存（默认为物理内存的1/64）

- -Xmx：最大堆空间内存（默认为物理内存的1/4）

- -Xmn：设置新生代的大小。（初始值及最大值）

- -XX:NewRatio：配置新生代与老年代在堆结构的占比

- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例（如果Eden区太大，导致Sx过小，就会导致Minor GC失去意义，每次回收都往老年代放了；如果Eden区过小，会导致Minor GC频率高，而且可能导致很多小对象直接进入老年代。）

- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄（年龄最大是15，是因为GC年龄存储在对象头中用4bit存储，最大就是15）

- -XX:+PrintGCDetails：输出详细的GC处理日志

  - 打印gc简要信息：① -XX:+PrintGC（是-XX:+PrintGCDetails的简化版） ② -verbose:gc

- -XX:HandlePromotionFalilure：是否设置空间分配担保

  - 在发生Minor GC之前，虚拟机会**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。
  - 如果大于，则此次Minor GC是安全的
  - 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。
    - 如果HandlePromotionFailure=true，那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
      - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
      - 如果小于，则改为进行一次Full GC。
    - 如果HandlePromotionFailure=false，则改为进行一次Full GC。
  - 在JDK6 Update24之后（JDK7），HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC**。

### 7.7.堆是否为分配对象的唯一选择

- 随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了
- 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是有一种特殊情况：如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化为栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了，这也是最常见的堆外存储技术
- 逃逸分析：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为参数被传递到其他地方中
- 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定这个对象是否将要分配在堆上
- JDK7默认开启逃逸分析
  - 通过`-XX:+DoEscapeAnalysis`显示开启逃逸分析
  - 通过`-XX:+PrintEscapeAnalysus`查看逃逸分析的筛选结果
- 因此在开发中能使用局部变量的，就不要在方法外定义
- 使用逃逸分析，编译器可对代码做如下优化：
  - 栈上分配：将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
  - 同步省略：如果一个对象被发现只能从一个线程访问到，那么对于这个对象的操作可以不考虑同步
  - 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中
    - 标量是指一个无法再分解为更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量，Java中的对象就是聚合量，因为它可以分解为其他的聚合量和标量
    - 在JIT阶段，如果经过逃逸分析，发现一个对象如果不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其其中包含的若干个成员变量来代替，这就是标量替换
    - 默认打开，可以通过`-XX:+EliminateAllocations`来显式开启
- 目前逃逸分析技术还不是很成熟，无法保证逃逸分析造成的性能消耗一定高于它减少的消耗，因此目前Hotspot未开启栈上分配，所有的对象仍是分配在堆上的，但是标量替换是在使用的



## 8.方法区

- 方法区可以看作是一块独立于Java堆的内存空间，各个线程间共享
- 方法区在JVM启动时的时候被创建，内存逻辑上连续，物理上可以不连续，关闭JVM时会释放这个区的内存
- 可以选择固定大小或者动态扩展
  - JDK7及以前：`-XX:PermSize`设置永久代初始分配空间，默认是20.75M，`-XX:MaxPermSize`设置永久代最大可分配空间，32为默认64M，64位默认82M
  - JDK8及以后：`-XX:MetaSpaceSize`设置元空间初始分配空间，默认值依赖于平台，Windows是21M，`-XX:MaxMetaSpaceSize`设置元空间最大可分配空间，默认值是-1即没有限制。初始元空间的大小相当于一个水位线，如果达到了这个大小会触发Full GC，卸载一些没用的类，如果Full GC释放的空间较小会适当的提高这个水位线，如果释放的空间较多会适当的降低这个水位线。为了避免频繁GC，可以将初始值设置为一个相对较高的值
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区移除，虚拟机回报OOM错误
- jdk7及以前，习惯上把方法区称为永久代，jdk8开始，使用元空间取代了永久代。本质上方法区和永久代不等价，仅仅是对hotspot而言是等价的。永久代使用的JVM的内存，元空间使用的本地内存，二者的内部结构也有区别

### 8.1.方法区的内部结构

- ![8](.\images\8.png)

- 方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 类型信息：对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
  - 这个类型的完整有效名称（全名=包名.类名）
  - 这个类型直接父类的完整有效名（对于interface或java.lang.Object而言，都没有父类）
  - 这个类型的修饰符（public, abstract, final的某个子集）
  - 这个类型直接接口的一个有序列表
- 域信息：
  - JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
  - 域的相关信息包括：域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)
- 方法信息
  - 方法名称
  - 方法的返回类型
  - 方法参数的数量和类型
  - 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的某个子集)
  - 方法的字节码(bytecodes)、操作数栈、局部变量表大小
  - 异常表
    - 每个异常处理开始的位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
- non-final的类变量：静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。类变量被类的所有实例共享，即使没有类实例时也可以访问
- 全局常量：static final的类变量，在编译时就会被赋值
- jdk1.6及之前：有永久代，静态变量存放在永久代上
- jdk1.7：有永久代，但已逐步去永久代，字符串常量池、静态变量保存在堆中
- jdk1.8：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍存在堆中

### 8.2.常量池

- 方法区内部包含了运行时常量池，字节码文件内部包含了常量池
- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表，包括各种字面量和对类型、域和方法的符号引用
- 常量池可以看作是一张表，虚拟机指令根据这张常量表找打要执行的类型、方法名、参数类型、字面量等类型
- 运行时常量池是方法区的一部分，常量池表时Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
- 运行时常量池在加载类和接口到虚拟机后，就会创建对应的运行时常量池
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据线就像数组一样，是通过索引访问的
- 运行时常量池中包含多种不通的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段的引用。此时不再是常量池中的符号地址了，这里转换为真实地址
  - 运行时常量池相对Class文件常量池另一重要的特征是：具备动态性
- 运行时常量池类似于传统语言中的符号表，但是它所包含的数据却比符号更加丰富一些
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值会报OOM



## 9.对象的实例化内存布局与访问定位

### 9.1.对象的实例化

- ![9](.\images\9.png)
- 指针碰撞：内存规整的情况下，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的治时期。分配内存就仅仅是把指针向空闲那边移动一段与对象大小相等的距离。如果垃圾收集器是基于压缩算法的，虚拟机就会采用这种分配方式
- 空闲列表：如果内存不规整，虚拟机会维护一个列表，记录哪些内存块是可以使用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的内容

### 9.2.对象的内存布局

- ![10](.\images\10.png)

### 9.3.对象的访问定位

- ![11](.\images\11.png)

- 句柄访问
  - ![12](.\images\12.png)
- 直接指针（HotSpot采用）
  - ![13](.\images\13.png)

## 10.直接内存

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
- 直接内存是在Java堆外的、直接向系统申请的内存区间
- 来源于NIO，通过存在堆中的DirectByBufeer操作Native内存
- 通常，访问直接内存的速度会优于Java堆，即读写性能高
  - 因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存
  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
- 可以通过`MaxDirectMemorySize`设置直接内存大小，如果不指定默认与堆的最大值`-Xmx`值相等
